//
//  GetChainCode.cpp
//  OpenTest
//
//  Created by Yun on 11/17/15.
//  Copyright Â© 2015 Yun. All rights reserved.
//

#include "GetChainCode.hpp"

struct node;
struct chain_segment{
    chain_code* chainCodes;
    chain_segment* next;
    chain_segment* previous;
    chain_segment* connectNext;
    bool isLeft;
    node* corrspondNode;
    chain_segment(bool is) : isLeft(is) {}
};

struct coordinates;
struct node{
    node* parent;
    chain_segment* left;
    chain_segment* right;
    vector<node*> children;
    string status;
    coordinates* coord;
    node(node* p,chain_segment* l,chain_segment* r,string s) : parent(p),left(l),right(r),status(s) {}
};
struct coordinates{
    node* whichNode;
    bool typeMin;
    int x;
    int y;
    coordinates(node* w,bool t, int xx, int yy) : whichNode(w),typeMin(t),x(xx),y(yy) {}
};

uchar getPixel(Mat src,int row,int col){
    if(row>=src.rows||row<0||col>=src.cols||col<0) return BACKGROUND;
    return src.at<uchar>(row,col);
}


bool isInvalid(Mat& PNH){
    for (int i=0;i<3 ; i++) {
        for (int j=0; j<3; j++) {
            if(getPixel(PNH, i, j)!=getPixel(PNH, 0, 0)) return false;
        }
    }
    return true;
}


bool isD0L(Mat& PNH){
    if(getPixel(PNH,1,0)==FOREGROUND &&
       getPixel(PNH,1,1)==FOREGROUND &&
       getPixel(PNH,2,0)==BACKGROUND &&
       getPixel(PNH,2,1)==BACKGROUND) return true;
    else return false;
}

bool isD0R(Mat& PNH){
    if(getPixel(PNH,0,0)==BACKGROUND &&
       getPixel(PNH,0,1)==BACKGROUND &&
       getPixel(PNH,1,0)==FOREGROUND &&
       getPixel(PNH,1,1)==FOREGROUND) return true;
    else return false;
}

bool isD1L(Mat& PNH){
    if(getPixel(PNH,0,0)==FOREGROUND &&
       getPixel(PNH,1,0)==BACKGROUND &&
       getPixel(PNH,1,1)==FOREGROUND) return true;
    else return false;
}

bool isD1R(Mat& PNH){
    if(getPixel(PNH,0,0)==FOREGROUND &&
       getPixel(PNH,0,1)==BACKGROUND &&
       getPixel(PNH,1,1)==FOREGROUND)
        return true;
    else return false;
}

bool isD2L(Mat& PNH){
    if(getPixel(PNH,0,0)==BACKGROUND &&
       getPixel(PNH,0,1)==FOREGROUND &&
       getPixel(PNH,1,0)==BACKGROUND &&
       getPixel(PNH,1,1)==FOREGROUND) return true;
    else return false;
}

bool isD2R(Mat& PNH){
    if(getPixel(PNH,0,1)==FOREGROUND &&
       getPixel(PNH,0,2)==BACKGROUND &&
       getPixel(PNH,1,1)==FOREGROUND &&
       getPixel(PNH,1,2)==BACKGROUND)
        return true;
    else return false;
}

bool isD3L(Mat& PNH){
    if(getPixel(PNH,0,1)==BACKGROUND &&
       getPixel(PNH,0,2)==FOREGROUND &&
       getPixel(PNH,1,1)==FOREGROUND)
        return true;
    else return false;
}

bool isD3R(Mat& PNH){
    if(getPixel(PNH,0,2)==FOREGROUND &&
       getPixel(PNH,1,1)==FOREGROUND &&
       getPixel(PNH,1,2)==BACKGROUND )
        return true;
    else return false;
}

bool isMin0(Mat& PNH){
    if(getPixel(PNH,2,0)==BACKGROUND &&
       getPixel(PNH,2,1)==BACKGROUND &&
       getPixel(PNH,2,2)==BACKGROUND &&
       getPixel(PNH,1,2)==BACKGROUND &&
       getPixel(PNH,1,1)==FOREGROUND)
        return true;
    else return false;
}

bool isMin1(Mat& PNH){
    if(getPixel(PNH,0,0)==BACKGROUND &&
       getPixel(PNH,0,1)==BACKGROUND &&
       getPixel(PNH,0,2)==FOREGROUND &&
       getPixel(PNH,1,1)==FOREGROUND &&
       getPixel(PNH,1,0)==FOREGROUND) return true;
    else if(getPixel(PNH,0,0)==FOREGROUND &&
            getPixel(PNH,0,1)==BACKGROUND &&
            getPixel(PNH,0,2)==FOREGROUND &&
            getPixel(PNH,1,1)==FOREGROUND) return true;
    else return false;
}

bool isMax0(Mat& PNH){
    if(getPixel(PNH,0,0)==BACKGROUND &&
       getPixel(PNH,0,1)==BACKGROUND &&
       getPixel(PNH,0,2)==BACKGROUND &&
       getPixel(PNH,1,0)==BACKGROUND &&
       getPixel(PNH,1,1)==FOREGROUND) return true;
    else return false;
}

bool isMax1(Mat& PNH){
    if(getPixel(PNH,2,0)==FOREGROUND &&
       getPixel(PNH,2,1)==BACKGROUND &&
       getPixel(PNH,2,2)==BACKGROUND &&
       getPixel(PNH,1,1)==FOREGROUND &&
       getPixel(PNH,1,2)==FOREGROUND) return true;
    else if(getPixel(PNH,2,0)==FOREGROUND &&
            getPixel(PNH,2,1)==BACKGROUND &&
            getPixel(PNH,2,2)==FOREGROUND &&
            getPixel(PNH,1,1)==FOREGROUND) return true;
    else return false;
}

bool isT(int i, Mat& PNH){
    if(i==0) return isD0L(PNH);
    if(i==1) return isD0R(PNH);
    if(i==2) return isD1L(PNH);
    if(i==3) return isD1R(PNH);
    if(i==4) return isD2L(PNH);
    if(i==5) return isD2R(PNH);
    if(i==6) return isD3L(PNH);
    if(i==7) return isD3R(PNH);
    return false;
}


int transferToChainCode(int t,bool isLeft){
    if (t/2 == 0){
        if(!isLeft) return 0;
        else return 4;
    }
    else if (t/2 == 1){
        if(!isLeft) return 7;
        return 3;
    }
    else if (t/2 == 2){
        if(!isLeft) return 6;
        return 2;
    }
    else{
        if(!isLeft) return 5;
        return 1;
    }
}

void searchDirections(Mat& PNH,bool &actchain_isLeft,chain_segment* &actchain_ptr,node* &CurrentHole,node* &CurrentObject,int &isMinPoint){
    isMinPoint=-1;
    for (int t=0; t<8; t++) {
        if(isT(t,PNH)){
            isMinPoint++;
            if(t==0){
                if(actchain_isLeft) (actchain_ptr->previous->previous->chainCodes->nodes).push_back(transferToChainCode(t, true));
                else  (actchain_ptr->previous->chainCodes->nodes).push_back(transferToChainCode(t, true));
            }
            else if(t==1) (actchain_ptr->previous->chainCodes->nodes).push_back(transferToChainCode(t, false));
            else{
                (actchain_ptr->chainCodes->nodes).push_back(transferToChainCode(t, actchain_isLeft));
                node* whichOne=actchain_ptr->corrspondNode;
                string str=whichOne->status;
                if(actchain_isLeft&&str=="potO")  CurrentObject=whichOne;
                else if(!actchain_isLeft&&str=="potH")  CurrentHole=whichOne;
                else if(actchain_isLeft&&str=="potH"){
                    CurrentHole=whichOne->parent->parent;
                    CurrentObject=whichOne->parent;
                }
                actchain_ptr=actchain_ptr->next;
                actchain_isLeft=!actchain_isLeft;
            }
        }
    }
}


void terminate(chain_segment* p, chain_segment* q,bool typeMin,node* &CurrentHole,node* &CurrentObject,int &currentCoordinateI, int &currentCoordinateJ,vector<coordinates*>& savedCoordinates){
    chain_segment* x;
    chain_segment* y;
    if(typeMin){
        x=p;
        y=q;
    }
    else{
        y=p;
        x=q;
    }
    node* whichLeft=p->corrspondNode;
    node* whichRight=q->corrspondNode;
    node* whichX=x->corrspondNode;
    node* whichY=y->corrspondNode;
    node* CurrentNode=NULL;
    
    if(whichLeft==whichRight){
        if(whichLeft->status=="potH") whichLeft->status="H";
        else whichLeft->status="O";
    }
    else if(whichLeft->status==whichRight->status){
        vector<node*> vecs;
        if(whichLeft->children.size()>=whichRight->children.size()){
            vecs=whichRight->parent->children;
            for(int r=0;r<vecs.size();r++){
                if(vecs[r]==whichRight){
                    whichRight->parent->children.erase(whichRight->parent->children.begin()+r);
                    whichRight->parent=NULL;
                    for (int s=0; s<whichRight->children.size(); s++) {
                        whichLeft->children.push_back(whichRight->children[s]);
                        whichRight->children[s]->parent=whichLeft;
                    }
                    break;
                }
            }
            whichLeft->right->corrspondNode=NULL;
            whichRight->left->corrspondNode=NULL;
            whichRight->right->corrspondNode=whichLeft;
            whichLeft->right=whichRight->right;
            CurrentNode=whichLeft;
        }
        else{
            vecs=whichLeft->parent->children;
            for(int r=0;r<vecs.size();r++){
                if(vecs[r]==whichLeft){
                    whichLeft->parent->children.erase(whichLeft->parent->children.begin()+r);
                    whichLeft->parent=NULL;
                    for (int s=0; s<whichLeft->children.size(); s++) {
                        whichRight->children.push_back(whichLeft->children[s]);
                        whichLeft->children[s]->parent=whichRight;
                    }
                    break;
                }
            }
            whichRight->left->corrspondNode=NULL;
            whichLeft->right->corrspondNode=NULL;
            whichLeft->left->corrspondNode=whichRight;
            whichRight->left=whichLeft->left;
            CurrentNode=whichRight;
        }
    }
    else{
        if(whichLeft->status=="potO"){
            vector<node*> vecs=whichX->parent->children;
            for(int r=0;r<vecs.size();r++){
                if(vecs[r]==whichX){
                    whichX->parent->children.erase(whichX->parent->children.begin()+r);
                    whichX->parent=NULL;
                    for (int s=0; s<whichX->children.size(); s++) {
                        whichY->children.push_back(whichX->children[s]);
                        whichX->children[s]->parent=whichY;
                    }
                    break;
                }
            }
            if(typeMin){
                whichY->right->corrspondNode=NULL;
                whichX->right->corrspondNode=NULL;
                whichX->left->corrspondNode=whichY;
                whichY->right=whichX->left;
            }
            else{
                whichY->left->corrspondNode=NULL;
                whichX->left->corrspondNode=NULL;
                whichX->right->corrspondNode=whichY;
                whichY->left=whichX->right;
            }
            CurrentNode=whichY->parent;
        }
        else{
            vector<node*> vecs=whichY->parent->children;
            for(int r=0;r<vecs.size();r++){
                if(vecs[r]==whichY){
                    whichY->parent->children.erase(whichY->parent->children.begin()+r);
                    whichY->parent=NULL;
                    for (int s=0; s<whichY->children.size(); s++) {
                        whichX->children.push_back(whichY->children[s]);
                        whichY->children[s]->parent=whichX;
                    }
                    break;
                }
            }
            if(typeMin){
                whichX->left->corrspondNode=NULL;
                whichY->left->corrspondNode=NULL;
                whichY->right->corrspondNode=whichX;
                whichX->left=whichY->right;
            }
            else{
                whichX->right->corrspondNode=NULL;
                whichY->right->corrspondNode=NULL;
                whichY->left->corrspondNode=whichX;
                whichX->right=whichY->left;
            }
            CurrentNode=whichX->parent;
            
        }
    }
    if (CurrentNode){
        if(typeMin) CurrentObject=CurrentNode;
        else  CurrentHole=CurrentNode;
    }
    else{
        coordinates* c=new coordinates(whichLeft,typeMin,currentCoordinateI,currentCoordinateJ);
        savedCoordinates.push_back(c);
        whichLeft->coord=c;
    }
}


void deleteFromChains(chain_segment* p ,chain_segment* q,bool typeMin,chain_segment* &actchain_ptr,node* &CurrentHole,node* &CurrentObject,int &currentCoordinateI,int &currentCoordinateJ,vector<coordinates*> &savedCoordinates){
    if(p->next==p->previous){
        actchain_ptr=NULL;
        terminate(p,q,typeMin,CurrentHole,CurrentObject,currentCoordinateI,currentCoordinateJ,savedCoordinates);
    }
    else{
        chain_segment* mid=p->previous;
        chain_segment* mid2=q->next;
        mid->next=mid2;
        mid2->previous=mid;
        terminate(p,q,typeMin,CurrentHole,CurrentObject,currentCoordinateI,currentCoordinateJ,savedCoordinates);
    }
}

void searchMinPoints(Mat& PNH,bool &actchain_isLeft,chain_segment* &actchain_ptr,node* &CurrentHole,node* &CurrentObject,int &isMinPoint,int &currentCoordinateI, int &currentCoordinateJ,vector<coordinates*>& savedCoordinates){
    if(isMinPoint<=0) return;
    chain_segment* p;
    chain_segment* q;
    if(actchain_isLeft){
        if(isMin1(PNH)){
            p=actchain_ptr->previous->previous->previous;
            q=actchain_ptr->previous->previous;
            p->connectNext=q;
            deleteFromChains(p,q,true,actchain_ptr,CurrentHole,CurrentObject,currentCoordinateI,currentCoordinateJ,savedCoordinates);
        }
        if(isMin0(PNH)){
            p=actchain_ptr->previous->previous;
            q=actchain_ptr->previous;
            q->connectNext=p;
            deleteFromChains(p,q,false,actchain_ptr,CurrentHole,CurrentObject,currentCoordinateI,currentCoordinateJ,savedCoordinates);
        }
    }
    else{
        if(isMin1(PNH)){
            p=actchain_ptr->previous->previous;
            q=actchain_ptr->previous;
            p->connectNext=q;
            deleteFromChains(p,q,true,actchain_ptr,CurrentHole,CurrentObject,currentCoordinateI,currentCoordinateJ,savedCoordinates);
        }
    }
    
}

void  insertToChains(chain_segment* left,chain_segment* right,chain_segment* &whichPtr){
    chain_segment* mid=whichPtr->previous;
    left->next=right;
    left->previous=mid;
    right->next=whichPtr;
    right->previous=left;
    whichPtr->previous=right;
    mid->next=left;
}

void searchMaxPoints(Mat& PNH,bool& actchain_isLeft,chain_segment* &actchain_ptr,node* &CurrentHole,node* &CurrentObject,int &currentCoordinateI, int& currentCoordinateJ){
    if(isD0L(PNH)) return;
    if(actchain_isLeft){
        if (isMax0(PNH)) {
            if(actchain_ptr==NULL){
                chain_segment* left=new chain_segment(true);
                chain_segment* right=new chain_segment(false);
                left->chainCodes=new chain_code(currentCoordinateI,currentCoordinateJ);
                right->chainCodes=new chain_code(currentCoordinateI,currentCoordinateJ);
                left->connectNext=right;
                left->previous=right;
                insertToChains(left,right,left);
                actchain_ptr=left;
                
                node* newNode=new node(CurrentHole,left,right,"potO");
                CurrentHole->children.push_back(newNode);
                CurrentObject=newNode;
                left->corrspondNode=newNode;
                right->corrspondNode=newNode;
            }
            else{
                chain_segment* left=new chain_segment(true);
                chain_segment* right=new chain_segment(false);
                left->chainCodes=new chain_code(currentCoordinateI,currentCoordinateJ);
                right->chainCodes=new chain_code(currentCoordinateI,currentCoordinateJ);
                left->connectNext=right;
                insertToChains(left,right,actchain_ptr);
                
                node* newNode=new node(CurrentHole,left,right,"potO");
                CurrentHole->children.push_back(newNode);
                CurrentObject=newNode;
                left->corrspondNode=newNode;
                right->corrspondNode=newNode;
            }
        }
        if(isMax1(PNH)){
            chain_segment* left=new chain_segment(false);
            chain_segment* right=new chain_segment(true);
            left->chainCodes=new chain_code(currentCoordinateI,currentCoordinateJ);
            right->chainCodes=new chain_code(currentCoordinateI,currentCoordinateJ);
            right->connectNext=left;
            insertToChains(left,right,actchain_ptr->previous);
            
            node* newNode=new node(CurrentObject,left,right,"potH");
            CurrentObject->children.push_back(newNode);
            left->corrspondNode=newNode;
            right->corrspondNode=newNode;
        }
    }
    else{
        if(isMax1(PNH)){
            chain_segment* left=new chain_segment(false);
            chain_segment* right=new chain_segment(true);
            left->chainCodes=new chain_code(currentCoordinateI,currentCoordinateJ);
            right->chainCodes=new chain_code(currentCoordinateI,currentCoordinateJ);
            right->connectNext=left;
            insertToChains(left,right,actchain_ptr);
            
            node* newNode=new node(CurrentObject,left,right,"potH");
            CurrentObject->children.push_back(newNode);
            left->corrspondNode=newNode;
            right->corrspondNode=newNode;
        }
    }
}


void* extractChainCodes(void* arg){
    Mat* src =(Mat*)arg;
    vector<chain_code*>* chainCodes=new vector<chain_code*>;
    Mat I;
    threshold(*src, I, THRESHOLDVALUE, 255, CV_THRESH_BINARY);

    Mat PNH=Mat(3,3, CV_8UC(1),Scalar(BACKGROUND));
    chain_segment* actchain_ptr=NULL;
    bool actchain_isLeft=true;
    node* frame=new node(NULL,NULL,NULL,"frame");
    node* CurrentHole=frame;
    node* CurrentObject=NULL;
    int isMinPoint=0;
    int currentCoordinateI;
    int currentCoordinateJ;
    vector<coordinates*> savedCoordinates;

    for (int i=0; i<I.rows; i++) {
        for (int j=0; j<I.cols; j++) {
            currentCoordinateI=i;
            currentCoordinateJ=j;
            for( int di = 0; di < 3; di++) {
                for(int dj = 0; dj < 3; dj ++ ) {
                    PNH.at<uchar>(di, dj) = getPixel(I, i + di - 1, j + dj - 1);
                }
            }
            if (!isInvalid(PNH)) {
                if(getPixel(PNH, 1, 1)==BACKGROUND) continue;
                if(isMin0(PNH)&&isMax0(PNH)){
                    chain_code* ch=new chain_code(i,j);
                    chainCodes->push_back(ch);
                    continue;
                }
                searchDirections(PNH,actchain_isLeft,actchain_ptr,CurrentHole,CurrentObject,isMinPoint);
                searchMinPoints(PNH,actchain_isLeft,actchain_ptr,CurrentHole,CurrentObject,isMinPoint,currentCoordinateI,currentCoordinateJ,savedCoordinates);
                searchMaxPoints(PNH,actchain_isLeft,actchain_ptr,CurrentHole,CurrentObject,currentCoordinateI,currentCoordinateJ);
            }
        }

    }
    for(int n=0;n<savedCoordinates.size();n++){
        coordinates* c = savedCoordinates[n];
        chain_code* newChain=new chain_code(c->x,c->y);
        chain_segment* moveChain;
        if(c->typeMin) moveChain=c->whichNode->right;
        else moveChain=c->whichNode->left;
        chain_segment* copyFirst=moveChain;
        while(true){
            vector<int> vecs=moveChain->chainCodes->nodes;
            if(moveChain->isLeft) reverse(vecs.begin(), vecs.end());
            for (int m=0; m<vecs.size(); m++) {
                newChain->nodes.push_back(vecs[m]);
            }
            moveChain=moveChain->connectNext;
            if(moveChain==copyFirst) break;
            //if(moveChain==NULL) break;
        }
        chainCodes->push_back(newChain);
    }
    pthread_exit((void*)chainCodes);;
}


vector<chain_code*>* extractChainCodes2(Mat* src){
    vector<chain_code*>* chainCodes=new vector<chain_code*>;
    Mat I;
    threshold(*src, I, THRESHOLDVALUE, 255, CV_THRESH_BINARY);
    
    Mat PNH=Mat(3,3, CV_8UC(1),Scalar(BACKGROUND));
    chain_segment* actchain_ptr=NULL;
    bool actchain_isLeft=true;
    node* frame=new node(NULL,NULL,NULL,"frame");
    node* CurrentHole=frame;
    node* CurrentObject=NULL;
    int isMinPoint=0;
    int currentCoordinateI;
    int currentCoordinateJ;
    vector<coordinates*> savedCoordinates;
    
    for (int i=0; i<I.rows; i++) {
        for (int j=0; j<I.cols; j++) {
            currentCoordinateI=i;
            currentCoordinateJ=j;
            for( int di = 0; di < 3; di++) {
                for(int dj = 0; dj < 3; dj ++ ) {
                    PNH.at<uchar>(di, dj) = getPixel(I, i + di - 1, j + dj - 1);
                }
            }
            if (!isInvalid(PNH)) {
                if(getPixel(PNH, 1, 1)==BACKGROUND) continue;
                if(isMin0(PNH)&&isMax0(PNH)){
                    chain_code* ch=new chain_code(i,j);
                    chainCodes->push_back(ch);
                    continue;
                }
                searchDirections(PNH,actchain_isLeft,actchain_ptr,CurrentHole,CurrentObject,isMinPoint);
                searchMinPoints(PNH,actchain_isLeft,actchain_ptr,CurrentHole,CurrentObject,isMinPoint,currentCoordinateI,currentCoordinateJ,savedCoordinates);
                searchMaxPoints(PNH,actchain_isLeft,actchain_ptr,CurrentHole,CurrentObject,currentCoordinateI,currentCoordinateJ);
            }
        }
        
    }
    for(int n=0;n<savedCoordinates.size();n++){
        coordinates* c = savedCoordinates[n];
        chain_code* newChain=new chain_code(c->x,c->y);
        chain_segment* moveChain;
        if(c->typeMin) moveChain=c->whichNode->right;
        else moveChain=c->whichNode->left;
        chain_segment* copyFirst=moveChain;
        while(true){
            vector<int> vecs=moveChain->chainCodes->nodes;
            if(moveChain->isLeft) reverse(vecs.begin(), vecs.end());
            for (int m=0; m<vecs.size(); m++) {
                newChain->nodes.push_back(vecs[m]);
            }
            moveChain=moveChain->connectNext;
            if(moveChain==copyFirst) break;
            //if(moveChain==NULL) break;
        }
        chainCodes->push_back(newChain);
    }
    return chainCodes;
}

//vector<chain_code*> extractChainCodesLayer(Mat src,int layer){
//    vector<chain_code*> chainCodes;
//    Mat I;
//    threshold(src, I, THRESHOLDVALUE, 255, CV_THRESH_BINARY);
//
//    Mat PNH=Mat(3,3, CV_8UC(1),Scalar(BACKGROUND));
//    chain_segment* actchain_ptr=NULL;
//    bool actchain_isLeft=true;
//    node* frame=new node(NULL,NULL,NULL,"frame");
//    node* CurrentHole=frame;
//    node* CurrentObject=NULL;
//    int isMinPoint = 0;
//    int currentCoordinateI;
//    int currentCoordinateJ;
//    vector<coordinates*> savedCoordinates;
//
//    for (int i=0; i<I.rows; i++) {
//        for (int j=0; j<I.cols; j++) {
//            currentCoordinateI=i;
//            currentCoordinateJ=j;
//            for( int di = 0; di < 3; di++) {
//                for(int dj = 0; dj < 3; dj ++ ) {
//                    PNH.at<uchar>(di, dj) = getPixel(I, i + di - 1, j + dj - 1);
//                }
//            }
//            if (!isInvalid(PNH)) {
//                if(getPixel(PNH, 1, 1)==BACKGROUND) continue;
//                if(isMin0(PNH)&&isMax0(PNH)) continue;
//                searchDirections(PNH,actchain_isLeft,actchain_ptr,CurrentHole,CurrentObject,isMinPoint);
//                searchMinPoints(PNH,actchain_isLeft,actchain_ptr,CurrentHole,CurrentObject,isMinPoint,currentCoordinateI,currentCoordinateJ,savedCoordinates);
//                searchMaxPoints(PNH,actchain_isLeft,actchain_ptr,CurrentHole,CurrentObject,currentCoordinateI,currentCoordinateJ);
//            }
//        }
//
//    }
//    int levels=0;
//    int parentSize=1, childSize=0;
//    int result=0;
//    int result2=0;
//    node * temp;
//    queue<node *> q;
//    q.push(frame);
//    do
//    {
//        temp = q.front();
//        if(temp!=frame&&temp->coord!=NULL){
//            coordinates* c = temp->coord;
//            chain_code* newChain=new chain_code(c->x,c->y);
//            chain_segment* moveChain;
//            if(c->typeMin) moveChain=c->whichNode->right;
//            else moveChain=c->whichNode->left;
//            chain_segment* copyFirst=moveChain;
//            result++;
//            while(true){
//                result2++;
//                vector<int> vecs=moveChain->chainCodes->nodes;
//                if(moveChain->isLeft) reverse(vecs.begin(), vecs.end());
//                for (int m=0; m<vecs.size(); m++) {
//                    newChain->nodes.push_back(vecs[m]);
//                }
//                moveChain=moveChain->connectNext;
//                if(moveChain==copyFirst) break;
//                //if(moveChain==NULL) break;
//            }
//            chainCodes.push_back(newChain);
//        }
//        q.pop();
//        for(int i=0; i<temp->children.size(); i++){
//                q.push(temp->children[i]);
//                childSize ++;
//        }
//        parentSize--;
//        if(parentSize == 0){
//            parentSize = childSize;
//            childSize = 0;
//            levels++;
//        }
//    } while(!q.empty()&&levels<=layer);
//    return chainCodes;
//}


//Mat toImageWithoutRC(vector<chain_code*> codes){
//    pair<int, int> p;
//    vector<pair<int, int>> vecp;
//    int row=0;
//    int col=0;
//    for (int i=0; i<codes.size(); i++) {
//        chain_code* c=codes[i];
//        int p1=c->x;
//        int p2=c->y;
//        p=make_pair(p1, p2);
//        if(p1>row) row=p1;
//        if(p2>col) col=p2;
//        vecp.push_back(p);
//        for (int j=0; j<c->nodes.size(); j++) {
//            int nodeDirect=c->nodes[j];
//            if(nodeDirect==0){
//                p2++;
//            }
//            else if(nodeDirect==1){
//                p1--;
//                p2++;
//            }
//            else if(nodeDirect==2){
//                p1--;
//            }
//            else if(nodeDirect==3){
//                p1--;
//                p2--;
//            }
//            else if(nodeDirect==4){
//                p2--;
//            }
//            else if(nodeDirect==5){
//                p1++;
//                p2--;
//            }
//            else if(nodeDirect==6){
//                p1++;
//            }
//            else if(nodeDirect==7){
//                p1++;
//                p2++;
//            }
//            vecp.push_back(make_pair(p1, p2));
//            if(p1>row) row=p1;
//            if(p2>col) col=p2;
//        }
//    }
//    Mat dest(row+1,col+1, CV_8UC(1),Scalar(BACKGROUND));
//    for (int i=0; i<vecp.size(); i++) {
//        dest.at<uchar>(vecp[i].first,vecp[i].second)=FOREGROUND;
//    }
//    return dest;
//}


void* extractChainCodesF1(void* arg){
    Mat* src =(Mat*)arg;
    vector<chain_code*> *chainCodes=new vector<chain_code*>;
    Mat I;
    threshold(*src, I, THRESHOLDVALUE, 255, CV_THRESH_BINARY);
    
    Mat PNH=Mat(3,3, CV_8UC(1),Scalar(BACKGROUND));
    chain_segment* actchain_ptr=NULL;
    bool actchain_isLeft=true;
    node* frame=new node(NULL,NULL,NULL,"frame");
    node* CurrentHole=frame;
    node* CurrentObject=NULL;
    int isMinPoint = 0;
    int currentCoordinateI;
    int currentCoordinateJ;
    vector<coordinates*> savedCoordinates;
    
    for (int i=0; i<I.rows; i++) {
        for (int j=0; j<I.cols; j++) {
            currentCoordinateI=i;
            currentCoordinateJ=j;
            for( int di = 0; di < 3; di++) {
                for(int dj = 0; dj < 3; dj ++ ) {
                    PNH.at<uchar>(di, dj) = getPixel(I, i + di - 1, j + dj - 1);
                }
            }
            if (!isInvalid(PNH)) {
                if(getPixel(PNH, 1, 1)==BACKGROUND) continue;
                if(isMin0(PNH)&&isMax0(PNH)){
                    chain_code* ch=new chain_code(i,j);
                    chainCodes->push_back(ch);
                    continue;
                }
                searchDirections(PNH,actchain_isLeft,actchain_ptr,CurrentHole,CurrentObject,isMinPoint);
                searchMinPoints(PNH,actchain_isLeft,actchain_ptr,CurrentHole,CurrentObject,isMinPoint,currentCoordinateI,currentCoordinateJ,savedCoordinates);
                searchMaxPoints(PNH,actchain_isLeft,actchain_ptr,CurrentHole,CurrentObject,currentCoordinateI,currentCoordinateJ);
            }
        }
        
    }
    int parentSize=1, childSize=0;
    node * temp;
    queue<node *> q;
    q.push(frame);
    do
    {
        temp = q.front();
        if(temp!=frame&&temp->coord!=NULL){
            coordinates* c = temp->coord;
            chain_code* newChain=new chain_code(c->x,c->y);
            chain_segment* moveChain;
            if(c->typeMin) moveChain=c->whichNode->right;
            else moveChain=c->whichNode->left;
           // moveChain=c->whichNode->left;
            chain_segment* copyFirst=moveChain;
            while(true){
                vector<int> vecs=moveChain->chainCodes->nodes;
                if(moveChain->isLeft) reverse(vecs.begin(), vecs.end());
                for (int m=0; m<vecs.size(); m++) {
                    newChain->nodes.push_back(vecs[m]);
                }
                moveChain=moveChain->connectNext;
                if(moveChain==copyFirst) break;
                //if(moveChain==NULL) break;
            }
            (chainCodes)->push_back(newChain);
        }
        q.pop();
        for(int i=0; i<temp->children.size(); i++){
            q.push(temp->children[i]);
            childSize ++;
        }
        parentSize--;
        if(parentSize == 0){
            parentSize = childSize;
            childSize = 0;
        }
    } while(!q.empty());
    pthread_exit((void*)chainCodes);
}


vector<chain_code*> * extractChainCodesF2(void* arg){
    Mat* src =(Mat*)arg;
    vector<chain_code*> *chainCodes=new vector<chain_code*>;
    Mat I;
    threshold(*src, I, THRESHOLDVALUE, 255, CV_THRESH_BINARY);
    
    Mat PNH=Mat(3,3, CV_8UC(1),Scalar(BACKGROUND));
    chain_segment* actchain_ptr=NULL;
    bool actchain_isLeft=true;
    node* frame=new node(NULL,NULL,NULL,"frame");
    node* CurrentHole=frame;
    node* CurrentObject=NULL;
    int isMinPoint = 0;
    int currentCoordinateI;
    int currentCoordinateJ;
    vector<coordinates*> savedCoordinates;
    
    for (int i=0; i<I.rows; i++) {
        for (int j=0; j<I.cols; j++) {
            currentCoordinateI=i;
            currentCoordinateJ=j;
            for( int di = 0; di < 3; di++) {
                for(int dj = 0; dj < 3; dj ++ ) {
                    PNH.at<uchar>(di, dj) = getPixel(I, i + di - 1, j + dj - 1);
                }
            }
            if (!isInvalid(PNH)) {
                if(getPixel(PNH, 1, 1)==BACKGROUND) continue;
                if(isMin0(PNH)&&isMax0(PNH)){
                    chain_code* ch=new chain_code(i,j);
                    chainCodes->push_back(ch);
                    continue;
                }
                searchDirections(PNH,actchain_isLeft,actchain_ptr,CurrentHole,CurrentObject,isMinPoint);
                searchMinPoints(PNH,actchain_isLeft,actchain_ptr,CurrentHole,CurrentObject,isMinPoint,currentCoordinateI,currentCoordinateJ,savedCoordinates);
                searchMaxPoints(PNH,actchain_isLeft,actchain_ptr,CurrentHole,CurrentObject,currentCoordinateI,currentCoordinateJ);
            }
        }
        
    }
    int parentSize=1, childSize=0;
    node * temp;
    queue<node *> q;
    q.push(frame);
    do
    {
        temp = q.front();
        if(temp!=frame&&temp->coord!=NULL){
            coordinates* c = temp->coord;
            chain_code* newChain=new chain_code(c->x,c->y);
            chain_segment* moveChain;
            if(c->typeMin) moveChain=c->whichNode->right;
            else moveChain=c->whichNode->left;
            chain_segment* copyFirst=moveChain;
            while(true){
                vector<int> vecs=moveChain->chainCodes->nodes;
                if(moveChain->isLeft) reverse(vecs.begin(), vecs.end());
                for (int m=0; m<vecs.size(); m++) {
                    newChain->nodes.push_back(vecs[m]);
                }
                moveChain=moveChain->connectNext;
                if(moveChain==copyFirst) break;
                //if(moveChain==NULL) break;
            }
            (chainCodes)->push_back(newChain);
        }
        q.pop();
        for(int i=0; i<temp->children.size(); i++){
            q.push(temp->children[i]);
            childSize ++;
        }
        parentSize--;
        if(parentSize == 0){
            parentSize = childSize;
            childSize = 0;
        }
    } while(!q.empty());
    return chainCodes;
}

Mat toImage(vector<chain_code*> codes,int row,int col){
    Mat dest(row,col, CV_8UC(1),Scalar(BACKGROUND));
    for (int i=0; i<codes.size(); i++) {
        chain_code* c=codes[i];
        int p1=c->x;
        int p2=c->y;
        dest.at<uchar>(p1,p2)=FOREGROUND;
        for (int j=0; j<c->nodes.size(); j++) {
            int nodeDirect=c->nodes[j];
            if(nodeDirect==0){
                p2++;
            }
            else if(nodeDirect==1){
                p1--;
                p2++;
            }
            else if(nodeDirect==2){
                p1--;
            }
            else if(nodeDirect==3){
                p1--;
                p2--;
            }
            else if(nodeDirect==4){
                p2--;
            }
            else if(nodeDirect==5){
                p1++;
                p2--;
            }
            else if(nodeDirect==6){
                p1++;
            }
            else if(nodeDirect==7){
                p1++;
                p2++;
            }
            dest.at<uchar>(p1,p2)=FOREGROUND;
        }
        
    }
    return dest;
}


void printChainCode(vector<chain_code*> codes){
    for (int i=0; i<codes.size(); i++) {
        chain_code* c=codes[i];
        int p1=c->x;
        int p2=c->y;
        cout<<"start point: ("<<to_string(p1)<<","<<to_string(p2)<<")"<<endl;
        for (int j=0; j<c->nodes.size(); j++) {
            int nodeDirect=c->nodes[j];
            if(nodeDirect==0){
                p2++;
            }
            else if(nodeDirect==1){
                p1--;
                p2++;
            }
            else if(nodeDirect==2){
                p1--;
            }
            else if(nodeDirect==3){
                p1--;
                p2--;
            }
            else if(nodeDirect==4){
                p2--;
            }
            else if(nodeDirect==5){
                p1++;
                p2--;
            }
            else if(nodeDirect==6){
                p1++;
            }
            else if(nodeDirect==7){
                p1++;
                p2++;
            }
            printf("(%d,%d)->",p1,p2);
            //cout<<nodeDirect;
        }
        cout<<endl<<endl;
    }
    cout<<"num of expect is "<<codes.size()<<endl;
}

void showImagePieces(vector<vector<chain_code*>*> vecs,vector<Mat>* pieces,int row, int col){
    int sizeCol=ceil(col/(double)PIECESIZE);
    int disp_rows=row;
    int disp_cols=col;
    Mat disp(disp_rows, disp_cols, CV_8UC(3),BACKGROUND);
    vector<Mat> vec_mat;
    for (int i=0; i<pieces->size(); i++){
        Mat m= toImage(*(vecs[i]),(*pieces)[i].rows,(*pieces)[i].cols);
        Mat n(m.rows, m.cols, CV_8UC(3),BACKGROUND);
        Mat_<Vec3b> _n = n;
        int max= ((i+1)/(double)(pieces->size()+1))*(256*256*256);
        int col1=max/(256*256);
        int col2=(max%(256*256))/256;
        int col3=(max%(256*256))%256;
        for (int r=0; r<m.rows; r++) {
            for (int s=0; s<m.cols; s++) {
                if(m.at<uchar>(r,s)==FOREGROUND){
                    _n(r,s)[0]=col1;
                    _n(r,s)[1]=col2;
                    _n(r,s)[2]=col3;
                }
                else{
                    _n(r,s)[0]=BACKGROUND;
                    _n(r,s)[1]=BACKGROUND;
                    _n(r,s)[2]=BACKGROUND;
                }
            }
        }
        n=_n;
        vec_mat.push_back(n);
    }
    for(int i=0;i<pieces->size();i++) {
        int topX=(i/sizeCol)*PIECESIZE;
        int topY=(i%sizeCol)*PIECESIZE;
        Mat imgROI = disp(Rect(topY,topX,((topY+PIECESIZE)>disp_cols?disp_cols-topY:PIECESIZE),((topX+PIECESIZE)>disp_rows?disp_rows-topX:PIECESIZE)));
        resize(vec_mat[i], imgROI,Size(vec_mat[i].cols,vec_mat[i].rows));
    }
    string window_name2 = "Result Image";
    namedWindow( window_name2, CV_WINDOW_AUTOSIZE );
    imshow( window_name2,disp);
    waitKey(0);
}


vector<vector<chain_code*>*> getChainCode(Mat& I){
    
    int sizeRow=ceil(I.rows/(double)PIECESIZE);
    int sizeCol=ceil(I.cols/(double)PIECESIZE);
    vector<Mat> pieces;
    for(int i=0;i<sizeRow;i++){
        for (int j=0; j<sizeCol; j++) {
            pieces.push_back(I(Range(i*PIECESIZE,((i+1)*PIECESIZE)>I.rows?I.rows:((i+1)*PIECESIZE)),Range(j*PIECESIZE,((j+1)*PIECESIZE)>I.cols?I.cols:((j+1)*PIECESIZE))));
        }
    }
//    string window_namet2 = "test Iamge";
//    namedWindow( window_namet2, CV_WINDOW_AUTOSIZE );
//    imshow( window_namet2,pieces[6]);
//    waitKey(0);
//
//    cout<<(pieces[6].at<uchar>(255,175)==BACKGROUND)<<endl;
//    vector<chain_code*> *vecc2=extractChainCodes2(&pieces[6]);
//    //printChainCode(*vecc2);
//    Mat expect2 = toImage(*vecc2, 256, 256);
//    string window_name4 = "Expect Iamge2";
//    namedWindow( window_name4, CV_WINDOW_AUTOSIZE );
//    imshow( window_name4,expect2);
//    waitKey(0);

    
    int numthread=(int)pieces.size();
    pthread_t* pth=(pthread_t*)malloc(sizeof(pthread_t)*numthread);
    //vector<chain_code*>** vecs=new vector<chain_code*>*[numthread]();
    vector<vector<chain_code*>*> vecs;
    for(int i=0; i<numthread;i++){
        vector<chain_code*>* p=new vector<chain_code*>();
        vecs.push_back(p);
    }
    for (int i=0; i<numthread; i++)pthread_create(&pth[i], NULL, extractChainCodes, (void*)&pieces[i]);
    for (int i=0; i<numthread; i++){
        pthread_join(pth[i], (void**)&vecs[i]);
    }
    
//    printChainCode(*vecs[34]);
//    Mat Itest= toImage(*vecs[34], 256, 256);
//    
//    string window_namet = "mid Iamge";
//    namedWindow( window_namet, CV_WINDOW_AUTOSIZE );
//    imshow( window_namet,Itest);
//    waitKey(0);

    
    showImagePieces(vecs,&pieces,I.rows,I.cols);
    
    return vecs;
}









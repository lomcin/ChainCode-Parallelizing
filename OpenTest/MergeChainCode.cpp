    //
//  MergeChainCode.cpp
//  OpenTest
//
//  Created by Yun on 11/17/15.
//  Copyright Â© 2015 Yun. All rights reserved.
//

#include "MergeChainCode.hpp"

vector<chain_code_block*> chain_block;

void getNextNode(int *p1,int *p2,int nodeDirect){
    if(nodeDirect==0){
        (*p2)++;
    }
    else if(nodeDirect==1){
        (*p1)--;
        (*p2)++;
    }
    else if(nodeDirect==2){
        (*p1)--;
    }
    else if(nodeDirect==3){
        (*p1)--;
        (*p2)--;
    }
    else if(nodeDirect==4){
        (*p2)--;
    }
    else if(nodeDirect==5){
        (*p1)++;
        (*p2)--;
    }
    else if(nodeDirect==6){
        (*p1)++;
    }
    else if(nodeDirect==7){
        (*p1)++;
        (*p2)++;
    }
}


int judgeInBorder(int p1,int p2,int row, int col){
    if(p1==row-1 && p2==col-1) return 4;
    if(p1==0 && p2==col-1) return 5;
    if(p1==0 && p2==0) return 6;
    if(p1==row-1 && p2==0) return 7;
    
    if(p2==col-1) return 1;
    if(p2==0) return 3;
    if(p1==row-1) return 0;
    if(p1==0) return 2;
    return -1;
}

vector<int> getChainCodePiece(vector<int> vec,int vbegin,int vend){
    vector<int> result;
    if(vbegin<vend){
        for (int i=vbegin; i<vend; i++) {
            result.push_back(vec[i]);
        }
    }
    else {
        for (int i=vbegin; i<vec.size(); i++) {
            result.push_back(vec[i]);
        }
        for (int i=0; i<vend; i++) {
            result.push_back(vec[i]);
        }
    }
    return result;
}

bool checkIfContains(int start1, int end1, int start2, int end2){
    if(start1==end2&&start2==end1){
        return false;
    }
    if(start1<end1){
        if(start2>end2){
            if(start2<=end1&&end2>=start1) return true;
        }
        else {
            if(end2<=end1&&start2>=start1) return true;
        }
    }
    else {
        if(start2<end2){
            if(start2>=end1&&end2<=start1) return true;
        }
        else {
            if(end2>=end1&&start2<=start1) return true;
        }
    }
    return false;
}


int startPoint(chain_code_point* chp){
    int x=chp->x;
    int y=chp->y;
    if(chp->type==0||chp->type==2) return y;
    if(chp->type==1||chp->type==3) return x;
    else return -1;
}


void insertToChainBorder(chain_code_point* chp){
    vector<chain_code_point*> vecs = chain_block[chp->whichPiece]->border[chp->type];
    int val;
    int val2;
    if(chp->type==1||chp->type==3){
        bool inOneChain=false;
        int i=0;
        while (i<vecs.size()) {
            if(checkIfContains(vecs[i]->x, vecs[i]->nextPoint->x,chp->x, chp->nextPoint->x)){
                inOneChain=true;
                break;
            }
            else if(checkIfContains(chp->x, chp->nextPoint->x,vecs[i]->x, vecs[i]->nextPoint->x)){
                chain_block[chp->whichPiece]->border[chp->type].erase(chain_block[chp->whichPiece]->border[chp->type].begin()+i);
                vecs.erase(vecs.begin()+i);
            }
            else i++;
        }
        if(! inOneChain){
            val=chp->x;
            bool b=false;
            for (int i=0; i<vecs.size(); i++) {
                val2=vecs[i]->x;
                if(val<val2){
                    chain_block[chp->whichPiece]->border[chp->type].insert(chain_block[chp->whichPiece]->border[chp->type].begin()+i, chp);
                    b=true;
                    break;
                }
            }
            if(!b) chain_block[chp->whichPiece]->border[chp->type].push_back(chp);
        }
    }
    else{
        bool inOneChain=false;
        int i=0;
        while(i<vecs.size()) {
            if(checkIfContains(vecs[i]->y, vecs[i]->nextPoint->y,chp->y, chp->nextPoint->y)){
                inOneChain=true;
                break;
            }
            else if(checkIfContains(chp->y, chp->nextPoint->y,vecs[i]->y, vecs[i]->nextPoint->y)){
                chain_block[chp->whichPiece]->border[chp->type].erase(chain_block[chp->whichPiece]->border[chp->type].begin()+i);
                vecs.erase(vecs.begin()+i);
            }
            else i++;
        }
        if(!inOneChain){
            val=chp->y;
            bool b=false;
            for (int i=0; i<vecs.size(); i++) {
                val2=vecs[i]->y;
                if(val>val2){
                    chain_block[chp->whichPiece]->border[chp->type].insert(chain_block[chp->whichPiece]->border[chp->type].begin()+i, chp);
                    b=true;
                    break;
                }
            }
            if(!b) chain_block[chp->whichPiece]->border[chp->type].push_back(chp);
        }
    }
}



void splitChainCode(chain_code* toSplit,int whichPiece,int row,int col, int index){
    int x=toSplit->x;
    int y=toSplit->y;
    if(toSplit->nodes.empty()){
        chain_block[whichPiece]->unbounded.push_back(toSplit);
        return;
    }
    
//    if(whichPiece==34&&index==248){
//        cout<<"helo"<<endl;
//    }
    int headx=x;
    int heady=y;
    int x_previous=x;
    int y_previous=y;
    getNextNode(&x, &y, toSplit->nodes[0]);
    int x_next=x;
    int y_next=y;
    getNextNode(&x_next, &y_next, toSplit->nodes[1]);
    int indexBegin=0;
    int headIndex=0;
    int headType=-1;
    chain_code_point* headIsSpeicalPoint=NULL;
    chain_code_point* headIsSpeicalPoint2=NULL;
    chain_code_point* chp0=NULL;
    chain_code_point* head=NULL;
    chain_code_point* chp1=NULL;
    for(int i=1;i<toSplit->nodes.size()+1;i++){ 
        x_next=x;
        y_next=y;
        if(i==toSplit->nodes.size()){
            x_next=headx;
            y_next=heady;
            getNextNode(&x_next, &y_next, toSplit->nodes[0]);
            i=0;
        }
        else getNextNode(&x_next, &y_next, toSplit->nodes[i]);
        if(judgeInBorder(x, y,row,col)!=-1){
            if(judgeInBorder(x, y, row, col)/4==1){
                if(judgeInBorder(x_previous, y_previous,row,col)==-1&&judgeInBorder(x_next, y_next,row,col)==-1){
                    continue;
                }
                else if(judgeInBorder(x_previous, y_previous,row,col)==-1) {
                    chain_code_point* chp=new chain_code_point(x,y);
                    chp->visited=false;
                    chp->visited2=false;
                    chp->special=false;
                    chp->lastConnectedPoint=NULL;
                    chp->goVisited=false;
                    chp->whichPiece=whichPiece;
                    chp->type=judgeInBorder(x_next, y_next, row, col);
                    chp->nextPoint=NULL;
                    chp->originalPoint=NULL;
                    chp->next=NULL;
                    chp->chainIndex=index;
                    if(!head){
                        head=chp;
                        headIndex=i;
                    }
                    else{
                        chain_code_split_piece* chs=new chain_code_split_piece();
                        chs->node=getChainCodePiece(toSplit->nodes,indexBegin,i);
                        chp0->next=chs;
                        chs->next=chp;
                    }
                    chp0=chp;
                    indexBegin=0;
                    //insertToChainBorder(chp);
                    //chain_block[whichPiece]->border[judgeInBorder(x_next, y_next, row, col)].push_back(chp);
                }
                else if(judgeInBorder(x_next, y_next,row,col)==-1){
                    chain_code_point* chp=new chain_code_point(x,y);
                    chp->visited=false;
                    chp->visited2=false;
                    chp->special=false;
                    chp->lastConnectedPoint=NULL;
                    chp->goVisited=false;
                    chp->whichPiece=whichPiece;
                    chp->type=judgeInBorder(x_previous, y_previous, row, col);
                    chp->nextPoint=NULL;
                    chp->originalPoint=NULL;
                    chp->next=NULL;
                    chp->chainIndex=index;
                    if(!head){
                        head=chp;
                        headIndex=i;
                        headType=judgeInBorder(x_previous, y_previous, row, col);
                    }
                    else{
                        if(chp1){
                            chp1->nextPoint=chp;
                            chp1->originalPoint=chp;
                            chp1->next=NULL;
                            if(abs(startPoint(chp1)- startPoint(chp))>abs(startPoint(chp1)- startPoint(chp0))){
                                insertToChainBorder(chp1);
                            }
                            else{
                                insertToChainBorder(chp0);
                            }
                            chp1=NULL;
                        }
                        else{
                            chp0->nextPoint=chp;
                            chp0->originalPoint=chp;
                            chp0->next=NULL;
                            insertToChainBorder(chp0);
                        }
                    }
                    indexBegin=i;
                    chp0=chp;
                }
                else if(judgeInBorder(x_next, y_next,row,col)!=-1&&judgeInBorder(x_previous, y_previous,row,col)!=-1&&x_previous==x_next&&y_previous==y_next){
                    chain_code_point* chp=new chain_code_point(x,y);
                    chp->visited=false;
                    chp->visited2=false;
                    chp->goVisited=false;
                    chp->special=false;
                    chp->lastConnectedPoint=NULL;
                    chp->whichPiece=whichPiece;
                    chp->type=judgeInBorder(x_previous, y_previous, row, col);
                    chp->nextPoint=NULL;
                    chp->originalPoint=NULL;
                    chp->next=NULL;
                    chp->chainIndex=index;
                    if(!head){
                        if(headIsSpeicalPoint){
                            headIsSpeicalPoint2=chp;
                        }
                        else  headIsSpeicalPoint=chp;
                    }
                    else{
                        chp0->nextPoint=chp;
                        chp0->originalPoint=chp;
                        chp1=chp;
                    }
                    indexBegin=0;
                } 
                else{
                    chain_code_point* chp=new chain_code_point(x,y);
                    chain_code_point* chp2=new chain_code_point(x,y);
                    chp->visited=false;
                    chp->visited2=false;
                    chp->goVisited=false;
                    chp->special=false;
                    chp->lastConnectedPoint=NULL;
                    chp->whichPiece=whichPiece;
                    chp->type=judgeInBorder(x_previous, y_previous, row, col);
                    chp->chainIndex=index;
                    chp2->visited=false;
                    chp2->visited2=false;
                    chp2->goVisited=false;
                    chp2->special=false;
                    chp2->lastConnectedPoint=NULL;
                    chp2->whichPiece=whichPiece;
                    chp2->type=judgeInBorder(x_next, y_next, row, col);
                    chp2->nextPoint=NULL;
                    chp2->originalPoint=NULL;
                    chp2->next=NULL;
                    chp2->chainIndex=index;
                    chp->nextPoint=chp2;
                    chp->originalPoint=chp2;
                    chp->next=NULL;
                    if(!head){
                        head=chp;
                        headIndex=i;
                        headType=judgeInBorder(x_previous, y_previous, row, col);
                    }
                    else{
                        if(chp1){
                            chp1->nextPoint=chp;
                            chp1->originalPoint=chp;
                            chp1->next=NULL;
                            if(abs(startPoint(chp1)- startPoint(chp))>abs(startPoint(chp1)- startPoint(chp0))){
                                insertToChainBorder(chp1);
                            }
                            else{
                                insertToChainBorder(chp0);
                            }
                            chp1=NULL;
                        }
                        else{
                            chp0->nextPoint=chp;
                            chp0->originalPoint=chp;
                            chp0->next=NULL;
                            insertToChainBorder(chp0);
                        }
                    }
                    chp0=chp2;
                    indexBegin=0;
                    //insertToChainBorder(chp2);
                    //chain_block[whichPiece]->border[judgeInBorder(x_next, y_next, row, col)].push_back(chp2);
                }
            }
            else{
                if(judgeInBorder(x_previous, y_previous,row,col)==-1&&judgeInBorder(x_next, y_next,row,col)==-1){
                    chain_code_point* chp=new chain_code_point(x,y);
                    chain_code_point* chp2=new chain_code_point(x,y);
                    chp->visited=false;
                    chp->visited2=false;
                    chp->goVisited=false;
                    chp->special=false;
                    chp->lastConnectedPoint=NULL;
                    chp->whichPiece=whichPiece;
                    chp->type=judgeInBorder(x, y, row, col);
                    chp->chainIndex=index;
                    chp2->visited=false;
                    chp2->visited2=false;
                    chp2->goVisited=false;
                    chp2->special=false;
                    chp2->lastConnectedPoint=NULL;
                    chp2->whichPiece=whichPiece;
                    chp2->type=judgeInBorder(x, y, row, col);
                    chp2->nextPoint=NULL;
                    chp2->originalPoint=NULL;
                    chp2->next=NULL;
                    chp2->chainIndex=index;
                    chp->nextPoint=chp2;
                    chp->originalPoint=chp2;
                    chp->next=NULL;
                    if(!head){
                        head=chp;
                        headIndex=i;
                    }
                    else{
                        chain_code_split_piece* chs=new chain_code_split_piece();
                        chs->node=getChainCodePiece(toSplit->nodes,indexBegin,i);
                        chp0->next=chs;
                        chs->next=chp;
                    }
                    indexBegin=i;
                    chp0=chp2;
                    //insertToChainBorder(chp);
                    //chain_block[whichPiece]->border[judgeInBorder(x, y, row, col)].push_back(chp);
                    
                }
                else if(judgeInBorder(x_previous, y_previous,row,col)==-1|| (judgeInBorder(x_previous, y_previous,row,col)<4&&judgeInBorder(x_previous, y_previous,row,col)!=judgeInBorder(x, y, row, col))){
                    chain_code_point* chp=new chain_code_point(x,y);
                    chp->visited=false;
                    chp->visited2=false;
                    chp->goVisited=false;
                    chp->special=false;
                    chp->lastConnectedPoint=NULL;
                    chp->whichPiece=whichPiece;
                    chp->type=judgeInBorder(x, y, row, col);
                    chp->nextPoint=NULL;
                    chp->originalPoint=NULL;
                    chp->next=NULL;
                    chp->chainIndex=index;
                    if(!head){
                        head=chp;
                        headIndex=i;
                    }
                    else{
                        chain_code_split_piece* chs=new chain_code_split_piece();
                        chs->node=getChainCodePiece(toSplit->nodes,indexBegin,i);
                        chp0->next=chs;
                        chs->next=chp;
                    }
                    chp0=chp;
                    indexBegin=0;
                    //insertToChainBorder(chp);
                    //chain_block[whichPiece]->border[judgeInBorder(x, y, row, col)].push_back(chp);
                    
                }
                else if(judgeInBorder(x_next, y_next,row,col)==-1||(judgeInBorder(x_next, y_next,row,col)<4&&judgeInBorder(x_next, y_next,row,col)!=judgeInBorder(x, y, row, col))){
                    chain_code_point* chp=new chain_code_point(x,y);
                    chp->visited=false;
                    chp->visited2=false;
                    chp->goVisited=false;
                    chp->special=false;
                    chp->lastConnectedPoint=NULL;
                    chp->whichPiece=whichPiece;
                    chp->type=judgeInBorder(x, y, row, col);
                    chp->nextPoint=NULL;
                    chp->originalPoint=NULL;
                    chp->next=NULL;
                    chp->chainIndex=index;
                    if(!head){
                        head=chp;
                        headIndex=i;
                        headType=judgeInBorder(x, y, row, col);
                    }
                    else{
                        if(chp1){
                            chp1->nextPoint=chp;
                            chp1->originalPoint=chp;
                            chp1->next=NULL;
                            if(abs(startPoint(chp1)- startPoint(chp))>abs(startPoint(chp1)- startPoint(chp0))){
                                insertToChainBorder(chp1);
                            }
                            else{
                                insertToChainBorder(chp0);
                            }
                            chp1=NULL;
                        }
                        else{
                            chp0->nextPoint=chp;
                            chp0->originalPoint=chp;
                            chp0->next=NULL;
                            insertToChainBorder(chp0);
                        }
                    }
                    indexBegin=i;
                    chp0=chp;
                }
                else if(judgeInBorder(x_next, y_next,row,col)!=-1&&judgeInBorder(x_previous, y_previous,row,col)!=-1&&x_previous==x_next&&y_previous==y_next){
                    chain_code_point* chp=new chain_code_point(x,y);
                    chp->visited=false;
                    chp->visited2=false;
                    chp->goVisited=false;
                    chp->special=false;
                    chp->lastConnectedPoint=NULL;
                    chp->whichPiece=whichPiece;
                    chp->type=judgeInBorder(x, y, row, col);
                    chp->nextPoint=NULL;
                    chp->originalPoint=NULL;
                    chp->next=NULL;
                    chp->chainIndex=index;
                    if(!head){
                        if(headIsSpeicalPoint){
                            headIsSpeicalPoint2=chp;
                        }
                        else  headIsSpeicalPoint=chp;
                    }
                    else{
                        chp0->nextPoint=chp;
                        chp0->originalPoint=chp;
                        chp1=chp;
                    }
                    indexBegin=0;
                }
            }
        }
        if(i!=0){
            x_previous=x;
            y_previous=y;
            getNextNode(&x, &y, toSplit->nodes[i]);
        }
        else break;
    }
    if(!chp0){
        if(headIsSpeicalPoint2){
            headIsSpeicalPoint->nextPoint=headIsSpeicalPoint2;
            headIsSpeicalPoint->originalPoint=headIsSpeicalPoint2;
            headIsSpeicalPoint2->nextPoint=headIsSpeicalPoint;
            headIsSpeicalPoint2->originalPoint=headIsSpeicalPoint;
            int s1 = startPoint(headIsSpeicalPoint);
            int s2 = startPoint(headIsSpeicalPoint2);
            if(headIsSpeicalPoint->type==0||headIsSpeicalPoint->type==3){
                if(s1>s2){
                    insertToChainBorder(headIsSpeicalPoint);
                    chain_block[whichPiece]->bounded.push_back(headIsSpeicalPoint);
                }
                else if(s1<s2){
                    insertToChainBorder(headIsSpeicalPoint2);
                    chain_block[whichPiece]->bounded.push_back(headIsSpeicalPoint2);
                }
            }
            else{
                if(s1<s2){
                    insertToChainBorder(headIsSpeicalPoint);
                    chain_block[whichPiece]->bounded.push_back(headIsSpeicalPoint);
                }
                else if(s1>s2){
                    insertToChainBorder(headIsSpeicalPoint2);
                    chain_block[whichPiece]->bounded.push_back(headIsSpeicalPoint2);
                }
            }
        }
        else chain_block[whichPiece]->unbounded.push_back(toSplit);
    }
    else{
        chain_block[whichPiece]->bounded.push_back(head);
        if(headType==-1){
            chain_code_split_piece* chs=new chain_code_split_piece();
            chs->node=getChainCodePiece(toSplit->nodes, indexBegin, headIndex);
            chp0->next=chs;
            chs->next=head;
        }
        else{
            if(headIsSpeicalPoint&&chp1){
                chp1->nextPoint=headIsSpeicalPoint;
                chp1->originalPoint=headIsSpeicalPoint;
                headIsSpeicalPoint->nextPoint=head;
                headIsSpeicalPoint->originalPoint=head;
                int a=abs(startPoint(chp0)- startPoint(chp1));
                int b=abs(startPoint(chp1)- startPoint(headIsSpeicalPoint));
                int c=abs(startPoint(headIsSpeicalPoint)- startPoint(head));
                if(a>b){
                    if(a>c){
                        insertToChainBorder(chp0);
                    }
                    else insertToChainBorder(headIsSpeicalPoint);
                }
                else{
                    if(b>c){
                        insertToChainBorder(chp1);
                    }
                    else insertToChainBorder(headIsSpeicalPoint);
                }
            }
            else if(headIsSpeicalPoint){
                chp0->nextPoint=headIsSpeicalPoint;
                chp0->originalPoint=headIsSpeicalPoint;
                headIsSpeicalPoint->nextPoint=head;
                headIsSpeicalPoint->originalPoint=head;
                headIsSpeicalPoint->next=NULL;
                if(abs(startPoint(headIsSpeicalPoint)- startPoint(head))>abs(startPoint(headIsSpeicalPoint)- startPoint(chp0))){
                    insertToChainBorder(headIsSpeicalPoint);
                }
                else{
                    insertToChainBorder(chp0);
                }
            }
            else if(chp1){
                chp1->nextPoint=head;
                chp1->originalPoint=head;
                chp1->next=NULL;
                if(abs(startPoint(chp1)- startPoint(head))>abs(startPoint(chp1)- startPoint(chp0))){
                    insertToChainBorder(chp1);
                }
                else{
                    insertToChainBorder(chp0);
                }
                chp1=NULL;
            }
            else{
                chp0->nextPoint=head;
                chp0->originalPoint=head;
                chp0->next=NULL;
                insertToChainBorder(chp0);
            }
        }
    }
}


void compareChainCodePiece(chain_code_point* beCompare,chain_code_point* toCompare){
    chain_code_point* beCompareNext = beCompare->originalPoint;
    chain_code_point* toCompareNext = toCompare->originalPoint;
    int beStart=startPoint(beCompare);
    int beEnd=startPoint(beCompareNext);
    int toStart=startPoint(toCompare);
    int toEnd=startPoint(toCompareNext);
    int judge=false;
    if(beStart<=beEnd){
        if(!(toStart<beStart||toEnd>beEnd)){
            judge=true;
        }
    }
    else{
        if(!(toEnd<beEnd||toStart>beStart)){
            judge=true;
        }
    }
    if(judge){
//        if(toCompare->visited&&beCompare->visited){
//            if(!beCompare->visited2){
//                chain_block[beCompare->whichPiece]->begins.push_back(beCompare);
//                beCompare->visited2=true;
//                beCompare->special=true;
//            }
//            if(!toCompare->visited2){
//                chain_block[toCompare->whichPiece]->begins.push_back(toCompare);
//                toCompare->visited2=true;
//                toCompare->special=true;
//            }
//        }
        if(toCompare->visited){
            beCompare->nextPoint=toCompare->nextPoint;
            toCompare->nextPoint=beCompareNext;
            beCompare->lastConnectedPoint=toCompare;
            if(!beCompare->visited2){
                chain_block[beCompare->whichPiece]->begins.push_back(beCompare);
                beCompare->visited2=true;
                beCompare->special=true;
            }
        }
        else if(beCompare->visited){
            toCompare->nextPoint=beCompareNext;
            beCompare->lastConnectedPoint->nextPoint=toCompareNext;
            if(!beCompare->lastConnectedPoint->visited2){
                chain_block[beCompare->lastConnectedPoint->whichPiece]->begins.push_back(beCompare->lastConnectedPoint);
                beCompare->lastConnectedPoint->visited2=true;
                beCompare->lastConnectedPoint->special=true;
            }
            beCompare->lastConnectedPoint=toCompare;
        }
        else {
            beCompare->nextPoint=toCompareNext;
            toCompare->nextPoint=beCompareNext;
            beCompare->lastConnectedPoint=toCompare;
            if(!beCompare->visited2){
                chain_block[beCompare->whichPiece]->begins.push_back(beCompare);
                beCompare->visited2=true;
            }
        }
        beCompare->visited=true;
        toCompare->visited=true;
    }
}

void connectChainCode(int beCompare,int toCompare,int type){
    vector<chain_code_point*> vecs=chain_block[beCompare]->border[(type+2)%4];
    for (int i=0; i<vecs.size(); i++) {
        for (int j=0; j<chain_block[toCompare]->border[type].size(); j++) {
            compareChainCodePiece(chain_block[beCompare]->border[(type+2)%4][i], chain_block[toCompare]->border[type][j]);
        }
    }
}

int getDirection(int type){
    if(type==0) return 6;
    if(type==1) return 0;
    if(type==2) return 2;
    if(type==3) return 4;
    return -1;
}

int getDirectionMove(int type,int moveUp){
    if(type==0||type==2){
        if(moveUp==0) return 0;
        if(moveUp==1) return 4;
    }
    if(type==1||type==3){
        if(moveUp==0) return 6;
        if(moveUp==1) return 2;
    }
    return -1;
}

int getDirectionMove2(int type,int moveUp){
    if(type==0){
        if(moveUp==0) return 7;
        if(moveUp==1) return 5;
    }
    if(type==1){
        if(moveUp==0) return 7;
        if(moveUp==1) return 1;
    }
    if(type==2){
        if(moveUp==0) return 1;
        if(moveUp==1) return 3;
    }
    if(type==3){
        if(moveUp==0) return 5;
        if(moveUp==1) return 3;
    }
    return -1;
}


int getDirectionMove3(int type,int moveUp){
    if(type==0){
        if(moveUp==0) return 1;
        if(moveUp==1) return 3;
    }
    if(type==1){
        if(moveUp==0) return 5;
        if(moveUp==1) return 3;
    }
    if(type==2){
        if(moveUp==0) return 7;
        if(moveUp==1) return 5;
    }
    if(type==3){
        if(moveUp==0) return 7;
        if(moveUp==1) return 1;
    }
    return -1;
}


bool checkForSpecialPoint(chain_code_point* chp,int sizeRow,int sizeCol,int rows,int cols){
    chain_code_point* start=chp;
    int count=0;
    do{
        int i=chp->whichPiece;
        int row= (i/sizeCol+1) * PIECESIZE > rows ? (rows - i/sizeCol * PIECESIZE) : PIECESIZE;
        int col= (i%sizeCol+1) * PIECESIZE > cols ? (cols - i%sizeCol * PIECESIZE) : PIECESIZE;
        if(judgeInBorder(chp->x, chp->y, row, col)<4) return false;
        count++;
        if(chp->nextPoint){
            chp=chp->nextPoint;
        }
        else return false;
    }while(chp!=start);
    return true;
}

//void printForTest(chain_code_point* chp){
//    chain_code_point* begin=chp;
//    do{
//        if(chp->next) chp=chp->next->next;
//        else{
//            cout<<"("<<chp->x<<","<<chp->y<<")--";
//            chp=chp->nextPoint;
//        }
//    }while(chp!=begin);
//}

vector<chain_code*> mergeChainCode(Mat& I){
    vector<chain_code*> chain_code_result;
    vector<vector<chain_code*>*> vecs=getChainCode(I);
    int rows=I.rows;
    int cols=I.cols;
    int sizeRow=ceil(rows/(double)PIECESIZE);
    int sizeCol=ceil(cols/(double)PIECESIZE);
    
    for (int i=0; i<vecs.size(); i++) {
        chain_code_block* chb= new chain_code_block();
        for (int j=0; j<4; j++) {
            vector<chain_code_point*> vecp2;
            chb->border.push_back(vecp2);
        }
        chain_block.push_back(chb);
    }
    
    for (int i=0; i<vecs.size(); i++) {
        int row= (i/sizeCol+1) * PIECESIZE > rows ? (rows - i/sizeCol * PIECESIZE) : PIECESIZE;
        int col= (i%sizeCol+1) * PIECESIZE > cols ? (cols - i%sizeCol * PIECESIZE) : PIECESIZE;
        for (int j=0; j<vecs[i]->size(); j++) {
            splitChainCode(vecs[i]->at(j), i, row, col,j);
        }
    }
    
    
    for (int i=0; i<sizeRow; i++) {
        for (int j=0; j<sizeCol-1; j++) {
            connectChainCode(i*sizeCol+j, i*sizeCol+j+1, 3);
        }
    }
    
    for (int i=0; i<sizeCol; i++) {
        for (int j=0; j<sizeRow-1; j++) {
            connectChainCode(j*sizeCol+i, (j+1)*sizeCol+i, 2);
        }
    }
    
    for (int i=0; i<chain_block.size(); i++) {
        vector<chain_code*> vec=chain_block[i]->unbounded;
        for (int j=0; j<vec.size(); j++) {
            vec[j]->x += i/sizeCol * PIECESIZE;
            vec[j]->y += i%sizeCol * PIECESIZE;
            chain_code_result.push_back(vec[j]);
        }
    }
    
    
    for (int i=0; i<chain_block.size(); i++) {
        vector<chain_code_point*> vec=chain_block[i]->bounded;
        for (int j=0; j<vec.size(); j++) {
            chain_code_point* start=vec[j];
            if(!start->goVisited){
                if(checkForSpecialPoint(start, sizeRow, sizeCol, rows, cols)) continue;
                int x = vec[j]->x + i/sizeCol * PIECESIZE;
                int y = vec[j]->y + i%sizeCol * PIECESIZE;
                chain_code* ch= new chain_code(x,y);
                chain_code_point* chp=start;
                vector<int> node;
                do{
                    if(chp->next){
                        for (int r=0; r<chp->next->node.size();r++) {
                            node.push_back(chp->next->node[r]);
                        }
                        chp->goVisited=true;
                        chp=chp->next->next;
                    }
                    else{
                        chain_code_point* nextOne=chp->nextPoint;
                        int s1=startPoint(chp);
                        int s2=startPoint(nextOne);
                        if(chp->x!=nextOne->x||chp->y!=nextOne->y){
                            if(chp->type!=nextOne->type){
                                if(s1!=s2){
                                    if( (s1<s2 && (chp->type==0||chp->type==3)) || (s1>s2 && (chp->type==1||chp->type==2)) ){
                                        node.push_back(getDirectionMove2(chp->type,s1>s2));
                                        for (int s=1; s<abs(s2-s1); s++) {
                                            node.push_back(getDirectionMove(chp->type,s1>s2));
                                        }
                                    }
                                    else {
                                        for (int s=1; s<abs(s2-s1); s++) {
                                            node.push_back(getDirectionMove(chp->type,s1>s2));
                                        }
                                        node.push_back(getDirectionMove2(chp->type,s1>s2));
                                    }
                                }
                                else node.push_back(getDirection(chp->type));
                            }
                            else{
                                if(chp->special){
                                    if(abs(s2-s1)>1){
                                        node.push_back(getDirectionMove2(chp->type,s1>s2));
                                        for (int s=0; s<abs(s2-s1)-2 ; s++) {
                                            node.push_back(getDirectionMove(chp->type,s1>s2));
                                        }
                                        node.push_back(getDirectionMove3(chp->type,s1>s2));
                                    }
                                    else node.push_back(getDirectionMove(chp->type,s1>s2));
                                }
                                else{
                                    for (int s=0; s<abs(s2-s1); s++) {
                                        node.push_back(getDirectionMove(chp->type,s1>s2));
                                    }
                                }
                            }
                        }
                        chp->goVisited=true;
                        chp=chp->nextPoint;
                    }
                } while(chp!=start);
                ch->nodes=node;
                chain_code_result.push_back(ch);
            }
        }
    }
    
    for (int i=0; i<chain_block.size(); i++) {
        vector<chain_code_point*> vec=chain_block[i]->begins;
        for (int j=0; j<vec.size(); j++) {
            chain_code_point* start=vec[j];
            if(!start->goVisited){
                if(checkForSpecialPoint(start, sizeRow, sizeCol, rows, cols)) continue;
                int x = vec[j]->x + i/sizeCol * PIECESIZE;
                int y = vec[j]->y + i%sizeCol * PIECESIZE;
                chain_code* ch= new chain_code(x,y);
                chain_code_point* chp=start;
                vector<int> node;
                do{
                    if(chp->next){
                        for (int r=0; r<chp->next->node.size();r++) {
                            node.push_back(chp->next->node[r]);
                        }
                        chp->goVisited=true;
                        chp=chp->next->next;
                    }
                    else{
                        chain_code_point* nextOne=chp->nextPoint;
                        int s1=startPoint(chp);
                        int s2=startPoint(nextOne);
                        if(chp->x!=nextOne->x||chp->y!=nextOne->y){
                            if(chp->type!=nextOne->type){
                                if(s1!=s2){
                                    if( (s1<s2 && (chp->type==0||chp->type==3)) || (s1>s2 && (chp->type==1||chp->type==2)) ){
                                        node.push_back(getDirectionMove2(chp->type,s1>s2));
                                        for (int s=1; s<abs(s2-s1); s++) {
                                            node.push_back(getDirectionMove(chp->type,s1>s2));
                                        }
                                    }
                                    else {
                                        for (int s=1; s<abs(s2-s1); s++) {
                                            node.push_back(getDirectionMove(chp->type,s1>s2));
                                        }
                                        node.push_back(getDirectionMove2(chp->type,s1>s2));
                                    }
                                }
                                else node.push_back(getDirection(chp->type));
                            }
                            else{
                                if(chp->special){
                                    if(abs(s2-s1)>1){
                                        node.push_back(getDirectionMove2(chp->type,s1>s2));
                                        for (int s=0; s<abs(s2-s1)-2; s++) {
                                            node.push_back(getDirectionMove(chp->type,s1>s2));
                                        }
                                        node.push_back(getDirectionMove3(chp->type,s1>s2));
                                    }
                                    else node.push_back(getDirectionMove(chp->type,s1>s2));
                                }
                                else{
                                    for (int s=0; s<abs(s2-s1); s++) {
                                        node.push_back(getDirectionMove(chp->type,s1>s2));
                                    }
                                }
                            }
                        }
                        chp->goVisited=true;
                        chp=chp->nextPoint;
                    }
                } while(chp!=start);
                ch->nodes=node;
                chain_code_result.push_back(ch);
            }
        }
    }
    
    return chain_code_result;
}








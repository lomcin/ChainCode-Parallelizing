      //
//  MergeChainCode.cpp
//  OpenTest
//
//  Created by Yun on 11/17/15.
//  Copyright Â© 2015 Yun. All rights reserved.
//

#include "MergeChainCode.hpp"

#include <pthread.h>

static vector<chain_code_block*> chain_block;
static pthread_mutex_t g_pmutex;
static vector<Mat> pieces;
static int numPiece;
static int processedPiece;
static int numthread;
static int sizeRow;
static int sizeCol;
static int rows;
static int cols;

void getNextNode(int& p1,int& p2,int nodeDirect){
    if(nodeDirect==0){
         p2++;
    }
    else if(nodeDirect==1){
        p1--;
        p2++;
    }
    else if(nodeDirect==2){
        p1--;
    }
    else if(nodeDirect==3){
        p1--;
        p2--;
    }
    else if(nodeDirect==4){
        p2--;
    }
    else if(nodeDirect==5){
        p1++;
        p2--;
    }
    else if(nodeDirect==6){
        p1++;
    }
    else if(nodeDirect==7){
        p1++;
        p2++;
    }
}

int startPoint(chain_code_point* chp){
    int x=chp->x;
    int y=chp->y;
    if(chp->type==0||chp->type==2){
        return y;
    }
    if(chp->type==1||chp->type==3){
        return x;
    }
    else return -1;
}

int getDirection(int type){
    if(type==0) return 6;
    if(type==1) return 0;
    if(type==2) return 2;
    if(type==3) return 4;
    return -1;
}

int getDirectionMove(int type,int moveUp){
    if(type==0||type==2){
        if(moveUp==0) return 0;
        if(moveUp==1) return 4;
    }
    if(type==1||type==3){
        if(moveUp==0) return 6;
        if(moveUp==1) return 2;
    }
    return -1;
}

int getDirectionMove2(int type,int moveUp){
    if(type==0){
        if(moveUp==0) return 7;
        if(moveUp==1) return 5;
    }
    if(type==1){
        if(moveUp==0) return 7;
        if(moveUp==1) return 1;
    }
    if(type==2){
        if(moveUp==0) return 1;
        if(moveUp==1) return 3;
    }
    if(type==3){
        if(moveUp==0) return 5;
        if(moveUp==1) return 3;
    }
    return -1;
}


int getDirectionMove3(int type,int moveUp){
    if(type==0){
        if(moveUp==0) return 1;
        if(moveUp==1) return 3;
    }
    if(type==1){
        if(moveUp==0) return 5;
        if(moveUp==1) return 3;
    }
    if(type==2){
        if(moveUp==0) return 7;
        if(moveUp==1) return 5;
    }
    if(type==3){
        if(moveUp==0) return 7;
        if(moveUp==1) return 1;
    }
    return -1;
}


int judgeInBorder(int p1,int p2,int row, int col){
    if(p1==row-1 && p2==col-1) return 4;
    if(p1==0 && p2==col-1) return 5;
    if(p1==0 && p2==0) return 6;
    if(p1==row-1 && p2==0) return 7;
    
    if(p2==col-1) return 1;
    if(p2==0) return 3;
    if(p1==row-1) return 0;
    if(p1==0) return 2;
    return -1;
}

int oneCornerBorder(int angle){
    if(angle==4){
        return 1;
    }
    if(angle==5){
        return 2;
    }
    if(angle==6){
        return 3;
    }
    if(angle==7){
        return 0;
    }
    return -1;
}


int anotherBorder(int border, int angle){
    if(angle==4){
        if(border==0) return 1;
        else return 0;
    }
    if(angle==5){
        if(border==1) return 2;
        else return 1;
    }
    if(angle==6){
        if(border==2) return 3;
        else return 2;
    }
    if(angle==7){
        if(border==3) return 0;
        else return 3;
    }
    return -1;
}

bool checkOppAngle(int a,int b,int sizeCol){
    if(a==b+1||a==b-1||a==b+sizeCol||a==b-sizeCol){
        return false;
    }
    return true;
}

void registerCorner(int angle,int whichPiece,chain_code_point* chp){
    if(angle==4){
        chain_block[whichPiece]->bottomRight=chp;
    }
    if(angle==5){
        chain_block[whichPiece]->topRight=chp;
    }
    if(angle==6){
        chain_block[whichPiece]->topLeft=chp;
    }
    if(angle==7){
        chain_block[whichPiece]->bottomLeft=chp;
    }
}

vector<int> getChainCodePiece(const vector<int>& vec,int vbegin,int vend){
    vector<int> result;
    if(vbegin<vend){
        for (int i=vbegin; i<vend; i++) {
            result.push_back(vec[i]);
        }
    }
    else {
        for (int i=vbegin; i<vec.size(); i++) {
            result.push_back(vec[i]);
        }
        for (int i=0; i<vend; i++) {
            result.push_back(vec[i]);
        }
    }
    return result;
}


bool reversePoint(int x,int y,int x_previous,int y_previous,int x_next,int y_next,int type){
    if(type==0){
        if(y_previous<y&&y_next>y) return true;
    }
    if(type==1){
        if(x_previous>x&&x_next<x) return true;
    }
    if(type==2){
        if(y_previous>y&&y_next<y) return true;
    }
    if(type==3){
        if(x_previous<x&&x_next>x) return true;
    }
    return false;
}



bool checkIfContains(int start1, int end1, int start2, int end2){
    if(start1==end2&&start2==end1){
        return false;
    }
    if(start1<end1){
        if(start2>end2){
            if(start2<=end1&&end2>=start1) return true;
        }
        else {
            if(end2<=end1&&start2>=start1) return true;
        }
    }
    else {
        if(start2<end2){
            if(start2>=end1&&end2<=start1) return true;
        }
        else {
            if(end2>=end1&&start2<=start1) return true;
        }
    }
    return false;
}

void insertToChainBorder(chain_code_point* chp){
    if(chp->inserted) return;
    vector<chain_code_point*> & vecs = chain_block[chp->whichPiece]->border[chp->type];
    int val;
    int val2;
    if(chp->type==1||chp->type==3){
        bool inOneChain=false;
        int i=0;
        while (i<vecs.size()) {
            if(checkIfContains(vecs[i]->x, vecs[i]->nextPoint->x,chp->x, chp->nextPoint->x)){
                inOneChain=true;
                break;
            }
            else if(checkIfContains(chp->x, chp->nextPoint->x,vecs[i]->x, vecs[i]->nextPoint->x)){
                vecs.erase(vecs.begin()+i);
            }
            else i++;
        }
        if(! inOneChain){
            val=chp->x;
            bool b=false;
            for (int i=0; i<vecs.size(); i++) {
                val2=vecs[i]->x;
                if(val<val2){
                    chp->inserted=true;
                    vecs.insert(vecs.begin()+i, chp);
                    b=true;
                    break;
                }
            }
            if(!b){
                chp->inserted=true;
                vecs.push_back(chp);
            }
        }
    }
    else{
        bool inOneChain=false;
        int i=0;
        while(i<vecs.size()) {
            if(checkIfContains(vecs[i]->y, vecs[i]->nextPoint->y,chp->y, chp->nextPoint->y)){
                inOneChain=true;
                break;
            }
            else if(checkIfContains(chp->y, chp->nextPoint->y,vecs[i]->y, vecs[i]->nextPoint->y)){
                vecs.erase(vecs.begin()+i);
            }
            else i++;
        }
        if(!inOneChain){
            val=chp->y;
            bool b=false;
            for (int i=0; i<vecs.size(); i++) {
                val2=vecs[i]->y;
                if(val>val2){
                    chp->inserted=true;
                    vecs.insert(vecs.begin()+i, chp);
                    b=true;
                    break;
                }
            }
            if(!b){
                chp->inserted=true;
                vecs.push_back(chp);
            }
        }
    }
}


void repeatedLineInsert(chain_code_point* chp0,chain_code_point* chp1, chain_code_point* chp){
    if(chp->type==1||chp->type==2){
        if(startPoint(chp)<startPoint(chp1)) insertToChainBorder(chp0);
        else insertToChainBorder(chp1);
    }
    else{
        if(startPoint(chp)<startPoint(chp1)) insertToChainBorder(chp1);
        else insertToChainBorder(chp0);
    }
}

bool compareBigger(chain_code_point* chp0,chain_code_point* chp1){
    if(chp1->type==1||chp1->type==3){
        if(startPoint(chp0)>startPoint(chp1)) return true;
    }
    else{
        if(startPoint(chp0)<startPoint(chp1)) return true;
    }
    return false;
}

void splitChainCode(chain_code* toSplit,int whichPiece,int row,int col, int index){
    int x=toSplit->x;
    int y=toSplit->y;
    if(toSplit->nodes.empty()){
        int type=judgeInBorder(x, y, row, col);
        if(type!=-1 && type<4){
            chain_code_point* chp=new chain_code_point(x,y,whichPiece,index,type,type);
            chain_code_point* chp2=new chain_code_point(x,y,whichPiece,index,type,type);
            chp->nextPoint=chp2;
            chp->originalPoint=chp2;
            chp2->nextPoint=chp;
            chp2->originalPoint=chp;
            insertToChainBorder(chp);
        }
        else if(type>=4){
            int type1=oneCornerBorder(type);
            int type2 =anotherBorder(type1, type);
            chain_code_point* chp=new chain_code_point(x,y,whichPiece,index,type1,type);
            chain_code_point* chp2=new chain_code_point(x,y,whichPiece,index,type1,type);
            chain_code_point* chp3=new chain_code_point(x,y,whichPiece,index,type2,type);
            chain_code_point* chp4=new chain_code_point(x,y,whichPiece,index,type2,type);
            chp->nextPoint=chp2;
            chp->originalPoint=chp2;
            chp2->nextPoint=chp3;
            chp2->originalPoint=chp3;
            chp3->nextPoint=chp4;
            chp3->originalPoint=chp4;
            chp4->nextPoint=chp;
            chp4->originalPoint=chp;
            insertToChainBorder(chp);
            insertToChainBorder(chp3);
            registerCorner(type,whichPiece,chp);
        }
        chain_block[whichPiece]->unbounded.push_back(toSplit);
        return;
    }
    int headx=x;
    int heady=y;
    int x_previous=x;
    int y_previous=y;
    getNextNode(x, y, toSplit->nodes[0]);
    int x_next=x;
    int y_next=y;
    getNextNode(x_next, y_next, toSplit->nodes[1]);
    int indexBegin=0;
    int headIndex=0;
    int headType=-1;
    chain_code_point* chp0=NULL;
    chain_code_point* head=NULL;
    chain_code_point* chp1=NULL;
    chain_code_point* repeatedHeadPoint = NULL;
    bool repeatedHead = false;
    bool InBorderOrNot = false;
    for(int i=1;i<toSplit->nodes.size()+1;i++){
        x_next=x;
        y_next=y;
        if(i==toSplit->nodes.size()){
            x_next=headx;
            y_next=heady;
            getNextNode(x_next, y_next, toSplit->nodes[0]);
            i=0;
        }
        else getNextNode(x_next, y_next, toSplit->nodes[i]);
        int typeSelf=judgeInBorder(x, y, row, col);
        int typePrevious=judgeInBorder(x_previous, y_previous, row, col);
        int typeNext=judgeInBorder(x_next, y_next, row, col);
        if(typeSelf!=-1){
            if(typeSelf/4==1){
                if(typePrevious==-1&&typeNext==-1){
                    int type1=oneCornerBorder(typeSelf);
                    int type2 =anotherBorder(type1, typeSelf);
                    chain_code_point* chp=new chain_code_point(x,y,whichPiece,index,type1,typeSelf);
                    chain_code_point* chp2=new chain_code_point(x,y,whichPiece,index,type1,typeSelf);
                    chain_code_point* chp3=new chain_code_point(x,y,whichPiece,index,type2,typeSelf);
                    chain_code_point* chp4=new chain_code_point(x,y,whichPiece,index,type2,typeSelf);
                    chp->nextPoint=chp2;
                    chp->originalPoint=chp2;
                    chp2->nextPoint=chp3;
                    chp2->originalPoint=chp3;
                    chp3->nextPoint=chp4;
                    chp3->originalPoint=chp4;
                    if(reversePoint(x,y,x_previous,y_previous,x_next,y_next,type1)) chp->reversed=true;
                    insertToChainBorder(chp);
                    if(reversePoint(x,y,x_previous,y_previous,x_next,y_next,type2)) chp3->reversed=true;
                    insertToChainBorder(chp3);
                    registerCorner(typeSelf,whichPiece,chp);
                    if(!head){
                        head=chp;
                        headIndex=i;
                    }
                    else{
                        chain_code_split_piece* chs=new chain_code_split_piece(getChainCodePiece(toSplit->nodes,indexBegin,i));
                        chp0->next=chs;
                        chs->next=chp;
                    }
                    indexBegin=i;
                    chp0=chp4;
                    InBorderOrNot = true;
                }
                else if(typePrevious==-1) {
                    int type1=typeNext;
                    int type2 =anotherBorder(type1, typeSelf);
                    chain_code_point* chp=new chain_code_point(x,y,whichPiece,index,type1,typeSelf);
                    chain_code_point* chp2=new chain_code_point(x,y,whichPiece,index,type2,typeSelf);
                    chain_code_point* chp3=new chain_code_point(x,y,whichPiece,index,type2,typeSelf);
                    chp2->nextPoint=chp3;
                    chp2->originalPoint=chp3;
                    chp3->nextPoint=chp;
                    chp3->originalPoint=chp;
                    if(reversePoint(x,y,x_previous,y_previous,x_next,y_next,type2)) chp2->reversed=true;
                    insertToChainBorder(chp2);
                    registerCorner(typeSelf,whichPiece,chp2);
                    if(!head){
                        head=chp2;
                        headIndex=i;
                    }
                    else{
                        chain_code_split_piece* chs=new chain_code_split_piece(getChainCodePiece(toSplit->nodes,indexBegin,i));
                        chp0->next=chs;
                        chs->next=chp2;
                    }
                    chp0=chp;
                    indexBegin=0;
                    InBorderOrNot = true;
                }
                else if(typeNext==-1){
                    int type1=typePrevious;
                    int type2 =anotherBorder(type1, typeSelf);
                    chain_code_point* chp=new chain_code_point(x,y,whichPiece,index,type1,typeSelf);
                    chain_code_point* chp2=new chain_code_point(x,y,whichPiece,index,type2,typeSelf);
                    chain_code_point* chp3=new chain_code_point(x,y,whichPiece,index,type2,typeSelf);
                    chp->nextPoint=chp2;
                    chp->originalPoint=chp2;
                    chp2->nextPoint=chp3;
                    chp2->originalPoint=chp3;
                    if(reversePoint(x,y,x_previous,y_previous,x_next,y_next,type2)) chp2->reversed=true;
                    insertToChainBorder(chp2);
                    registerCorner(typeSelf,whichPiece,chp2);
                    if(!head){
                        head=chp;
                        headIndex=i;
                        headType=typePrevious;
                    }
                    else{
                        if(chp1){
                            chp1->nextPoint=chp;
                            chp1->originalPoint=chp;
                            repeatedLineInsert(chp0,chp1,chp);
                            chp1=NULL;
                        }
                        else{
                            chp0->nextPoint=chp;
                            chp0->originalPoint=chp;
                            if(!repeatedHead) insertToChainBorder(chp0);
                            else{
                                repeatedHead=false;
                                repeatedHeadPoint = chp;
                            }
                        }
                    }
                    indexBegin=i;
                    chp0=chp3;
                    InBorderOrNot = true;
                }
                else if(typeNext!=-1&&typePrevious!=-1&&x_previous==x_next&&y_previous==y_next){
                    int type1=typePrevious;
                    int type2 =anotherBorder(type1, typeSelf);
                    chain_code_point* chp=new chain_code_point(x,y,whichPiece,index,type1,typeSelf);
                    chain_code_point* chp2=new chain_code_point(x,y,whichPiece,index,type2,typeSelf);
                    chain_code_point* chp3=new chain_code_point(x,y,whichPiece,index,type2,typeSelf);
                    chain_code_point* chp4=new chain_code_point(x,y,whichPiece,index,type1,typeSelf);
                    chp4->nextPoint=chp2;
                    chp4->originalPoint=chp2;
                    chp2->nextPoint=chp3;
                    chp2->originalPoint=chp3;
                    chp3->nextPoint=chp;
                    chp3->originalPoint=chp;
                    insertToChainBorder(chp2);
                    registerCorner(typeSelf,whichPiece,chp2);
                    if(!head){
                        head=chp4;
                        headIndex=i;
                        headType=-2;
                        chp0=chp;
                        repeatedHead = true;
                    }
                    else{
                        if(chp1){
                            chp1->nextPoint=chp4;
                            chp1->originalPoint=chp4;
                            repeatedLineInsert(chp0,chp1,chp4);
                            chp0=chp1;
                        }
                        else{
                            chp0->nextPoint=chp4;
                            chp0->originalPoint=chp4;
                            if(repeatedHead){
                                repeatedHead=false;
                                repeatedHeadPoint = chp4;
                            }
                        }
                        chp1=chp;
                    }
                    indexBegin=0;
                } 
                else if(typeNext!=-1&&typePrevious!=-1&&typePrevious!=typeNext){
                    chain_code_point* chp=new chain_code_point(x,y,whichPiece,index,typePrevious,typeSelf);
                    chain_code_point* chp2=new chain_code_point(x,y,whichPiece,index,typeNext,typeSelf);
                    chp->nextPoint=chp2;
                    chp->originalPoint=chp2;
                    if(reversePoint(x,y,x_previous,y_previous,x_next,y_next,typeNext)) chp2->reversed=true;
                    registerCorner(typeSelf,whichPiece,chp);
                    if(!head){
                        head=chp;
                        headIndex=i;
                        headType=typePrevious;
                    }
                    else{
                        if(chp1){
                            chp1->nextPoint=chp;
                            chp1->originalPoint=chp;
                            repeatedLineInsert(chp0,chp1,chp);
                            chp1=NULL;
                        }
                        else{
                            chp0->nextPoint=chp;
                            chp0->originalPoint=chp;
                            if(!repeatedHead) insertToChainBorder(chp0);
                            else{
                                repeatedHead=false;
                                repeatedHeadPoint = chp;
                            }
                        }
                    }
                    chp0=chp2;
                    indexBegin=0;
                }
            }
            else{
                if((typePrevious==-1&&typeNext==-1)||(typePrevious==-1&&typeNext<4&&typeNext!=typeSelf)||(typeNext==-1&&typePrevious<4&&typePrevious!=typeSelf)){
                    chain_code_point* chp=new chain_code_point(x,y,whichPiece,index,typeSelf,typeSelf);
                    chain_code_point* chp2=new chain_code_point(x,y,whichPiece,index,typeSelf,typeSelf);
                    chp->nextPoint=chp2;
                    chp->originalPoint=chp2;
                    if(reversePoint(x,y,x_previous,y_previous,x_next,y_next,typeSelf)) chp->reversed=true;
                    if(!head){
                        head=chp;
                        headIndex=i;
                    }
                    else{
                        chain_code_split_piece* chs=new chain_code_split_piece(getChainCodePiece(toSplit->nodes,indexBegin,i));
                        chp0->next=chs;
                        chs->next=chp;
                    }
                    indexBegin=i;
                    chp0=chp2;
                    insertToChainBorder(chp);
                    InBorderOrNot = true;
                }
                else if(typePrevious==-1|| (typePrevious<4&&typePrevious!=typeSelf)){
                    chain_code_point* chp=new chain_code_point(x,y,whichPiece,index,typeSelf,typeSelf);
                    if(!head){
                        head=chp;
                        headIndex=i;
                    }
                    else{
                        chain_code_split_piece* chs=new chain_code_split_piece(getChainCodePiece(toSplit->nodes,indexBegin,i));
                        chp0->next=chs;
                        chs->next=chp;
                    }
                    chp0=chp;
                    indexBegin=0;
                    InBorderOrNot = true;
                }
                else if(typeNext==-1||(typeNext<4&&typeNext!=typeSelf)){
                    chain_code_point* chp=new chain_code_point(x,y,whichPiece,index,typeSelf,typeSelf);
                    if(!head){
                        head=chp;
                        headIndex=i;
                        headType=typeSelf;
                    }
                    else{
                        if(chp1){
                            chp1->nextPoint=chp;
                            chp1->originalPoint=chp;                            
                            repeatedLineInsert(chp0,chp1,chp);
                            chp1=NULL;
                        }
                        else{
                            chp0->nextPoint=chp;
                            chp0->originalPoint=chp;
                            if(!repeatedHead) insertToChainBorder(chp0);
                            else{
                                repeatedHead=false;
                                repeatedHeadPoint = chp;
                            }
                        }
                    }
                    chp0=chp;
                    indexBegin=i;
                    InBorderOrNot = true;
                }
                else if(typeNext!=-1&&typePrevious!=-1&&x_previous==x_next&&y_previous==y_next){
                    chain_code_point* chp=new chain_code_point(x,y,whichPiece,index,typeSelf,typeSelf);
                    if(!head){
                        head=chp;
                        headIndex=i;
                        headType=-2;
                        chp0=chp;
                        repeatedHead = true;
                    }
                    else{
                        if(chp1){
                            chp1->nextPoint=chp;
                            chp1->originalPoint=chp;
                            repeatedLineInsert(chp0,chp1,chp);
                            chp0=chp1;
                        }
                        else {
                            chp0->nextPoint=chp;
                            chp0->originalPoint=chp;
                            if(repeatedHead){
                                repeatedHead=false;
                                repeatedHeadPoint = chp;
                            }
                        }
                        chp1=chp;
                    }
                    indexBegin=0;
                }
            }
        }
        if(i!=0){
            x_previous=x;
            y_previous=y;
            getNextNode(x, y, toSplit->nodes[i]);
        }
        else break;
    }
    if(!InBorderOrNot){
        if(head){
            if(chp1){
                chp1->nextPoint=head;
                chp1->originalPoint=head;
                repeatedLineInsert(chp0, chp1, head);
                repeatedLineInsert(chp1, head, repeatedHeadPoint);
                chain_block[whichPiece]->bounded.push_back(head);
            }
            else{
                chp0->nextPoint=head;
                chp0->originalPoint=head;
                insertToChainBorder(chp0);
                chain_block[whichPiece]->bounded.push_back(head);
            }
        }
        else chain_block[whichPiece]->unbounded.push_back(toSplit);
    }
    else{
        chain_block[whichPiece]->bounded.push_back(head);
        if(!chp0) return;
        if(headType==-1){
            chain_code_split_piece* chs=new chain_code_split_piece(getChainCodePiece(toSplit->nodes, indexBegin, headIndex));
            chp0->next=chs;
            chs->next=head;
        }
        else{
            if(headType==-2&&chp1){
                chp1->nextPoint=head;
                chp1->originalPoint=head;
                repeatedLineInsert(chp0, chp1, head);
                repeatedLineInsert(chp1, head, repeatedHeadPoint);
            }
            else if(headType==-2){
                chp0->nextPoint=head;
                chp0->originalPoint=head;
                repeatedLineInsert(chp0,head,repeatedHeadPoint);
            }
            else if(chp1){
                chp1->nextPoint=head;
                chp1->originalPoint=head;
                repeatedLineInsert(chp0,chp1,head);
                chp1=NULL;
            }
            else{
                chp0->nextPoint=head;
                chp0->originalPoint=head;
                insertToChainBorder(chp0);
            }
        }
    }
}


void compareChainCodePiece(chain_code_point* beCompare,chain_code_point* toCompare){
    chain_code_point* beCompareNext = beCompare->originalPoint;
    chain_code_point* toCompareNext = toCompare->originalPoint;
    int beStart=startPoint(beCompare);
    int beEnd=startPoint(beCompareNext);
    int toStart=startPoint(toCompare);
    int toEnd=startPoint(toCompareNext);
    int judge=false;
    if(beStart<beEnd){
        if(toStart>=toEnd&&!(toStart<beStart||toEnd>beEnd)){
            judge=true;
        }
    }
    else if(beStart>beEnd){
        if(toStart<=toEnd&&!(toEnd<beEnd||toStart>beStart)){
            judge=true;
        }
    }
    else{
        if((beCompare->reversed&&toCompare->reversed)||(!beCompare->reversed&&!toCompare->reversed)){
            if(toStart==toEnd&&abs(toStart-beStart)<=1) judge=true;
            else if((beStart<=toEnd&&beStart>=toStart)||(beStart>=toEnd&&beStart<=toStart)){
                judge=true;
            }
        }
        
//        if(toStart==toEnd&&abs(toStart-beStart)<=1){
//            if((beCompare->reversed&&toCompare->reversed)||(!beCompare->reversed&&!toCompare->reversed)){
//                judge=true;
//            }
//        }
//        else if((beStart<=toEnd&&beStart>=toStart)||(beStart>=toEnd&&beStart<=toStart)){
//            judge=true;
//        }
    }
    if(judge){
        if(toCompare->visited){
            if(compareBigger(beCompareNext, toCompare->nextPoint)){
                beCompare->nextPoint=toCompare->nextPoint;
                toCompare->nextPoint=beCompareNext;
                beCompare->lastConnectedPoint=toCompare;
                if(!beCompare->visited2){
                    pthread_mutex_lock(&g_pmutex);
                    chain_block[beCompare->whichPiece]->begins.push_back(beCompare);
                    pthread_mutex_unlock(&g_pmutex);
                    beCompare->visited2=true;
                    beCompare->special=true;
                }
            }
            else if(compareBigger(toCompare->firstConnectedPoint,beCompare)){
                beCompare->nextPoint=toCompareNext;
                toCompare->firstConnectedPoint->nextPoint=beCompareNext;
                if(!toCompare->firstConnectedPoint->visited2){
                    pthread_mutex_lock(&g_pmutex);
                    chain_block[beCompare->lastConnectedPoint->whichPiece]->begins.push_back(toCompare->firstConnectedPoint);
                    pthread_mutex_unlock(&g_pmutex);
                    toCompare->firstConnectedPoint->visited2=true;
                    toCompare->firstConnectedPoint->special=true;
                }
                toCompare->firstConnectedPoint=beCompare;
                beCompare->lastConnectedPoint=toCompare;
            }
        }
        else if(beCompare->visited){
            if(compareBigger(toCompare, beCompare->lastConnectedPoint)){
                toCompare->nextPoint=beCompareNext;
                beCompare->lastConnectedPoint->nextPoint=toCompareNext;
                if(!beCompare->lastConnectedPoint->visited2){
                    pthread_mutex_lock(&g_pmutex);
                    chain_block[beCompare->lastConnectedPoint->whichPiece]->begins.push_back(beCompare->lastConnectedPoint);
                    pthread_mutex_unlock(&g_pmutex);
                    beCompare->lastConnectedPoint->visited2=true;
                    beCompare->lastConnectedPoint->special=true;
                }
                beCompare->lastConnectedPoint=toCompare;
                toCompare->firstConnectedPoint=beCompare;
            }
            else if(compareBigger(beCompare->nextPoint,toCompareNext)){
                toCompare->nextPoint = beCompare->nextPoint;
                beCompare->nextPoint=toCompareNext;
                toCompare->firstConnectedPoint=beCompare;
                if(!toCompare->visited2){
                    pthread_mutex_lock(&g_pmutex);
                    chain_block[toCompare->whichPiece]->begins.push_back(toCompare);
                    pthread_mutex_unlock(&g_pmutex);
                    toCompare->visited2=true;
                    toCompare->special=true;
                }
            }
        }
        else {
            beCompare->nextPoint=toCompareNext;
            toCompare->nextPoint=beCompareNext;
            beCompare->lastConnectedPoint=toCompare;
            toCompare->firstConnectedPoint=beCompare;
            if(!beCompare->visited2){
                pthread_mutex_lock(&g_pmutex);
                chain_block[beCompare->whichPiece]->begins.push_back(beCompare);
                pthread_mutex_unlock(&g_pmutex);
                beCompare->visited2=true;
            }
        }
        beCompare->visited=true;
        toCompare->visited=true;
    }
}

void connectChainCode(int beCompare,int toCompare,int type){
    vector<chain_code_point*>& vecs=chain_block[beCompare]->border[(type+2)%4];
    for (int i=0; i<vecs.size(); i++) {
        for (int j=0; j<chain_block[toCompare]->border[type].size(); j++) {
            compareChainCodePiece(vecs[i], chain_block[toCompare]->border[type][j]);
        }
    }
}


int checkForSpecialPoint(chain_code_point* chp){
    chain_code_point* start=chp;
    int count=0;
    do{
        if(chp->cornerType<4) return 0;
        count++;
        if(chp->nextPoint){
            if(chp->x!=chp->nextPoint->x||chp->y!=chp->nextPoint->y){
                if(chp->whichPiece==chp->nextPoint->whichPiece) return 0;
            }
            chp=chp->nextPoint;
        }
        else{
            return 0;
        }
    }while(chp!=start);
    return 1;
}



chain_code_point* checkForSpecialPoint2(chain_code_point* chp){
    int count=0;
    chain_code_point* start=chp;
    do{
        if(chp->cornerType<4) return NULL;
        if(chp->nextPoint){
            if(chp->x!=chp->nextPoint->x||chp->y!=chp->nextPoint->y){
                if(chp->whichPiece==chp->nextPoint->whichPiece) return NULL;
                count++;
            }
            chp=chp->nextPoint;
        }
        else{
            return NULL;
        }
    }while(count<2);
    if(chp->cornerType>3&&chp->whichPiece!=start->whichPiece){
        chain_code_point* chpp=chp;
        while(chpp->nextPoint&&chpp->nextPoint->x==chpp->x&&chpp->nextPoint->y==chpp->y){
            chpp=chpp->nextPoint;
        }
        if(chpp->nextPoint){
            if(chpp->nextPoint->cornerType<4){
                return chp;
            }
        }
        else return chp;
    }
    return NULL;
}


void printForTest(chain_code_point* chp){
    chain_code_point* begin=chp;
    do{
        cout<<"("<<chp->x<<","<<chp->y<<")--";
        if(chp->next) chp=chp->next->next;
        else{
            chp=chp->nextPoint;
        }
    }while(chp!=begin);
}


void compareCorner(int whichPiece){
    if(whichPiece%sizeCol>0&&whichPiece/sizeCol>0&&chain_block[whichPiece]->topLeft){
        if(!chain_block[whichPiece-1]->topRight&&!chain_block[whichPiece-sizeCol]->bottomLeft&&chain_block[whichPiece-sizeCol-1]->bottomRight){
            chain_code_point* beNext = chain_block[whichPiece]->topLeft->originalPoint;
            chain_code_point* ToNext = chain_block[whichPiece-sizeCol-1]->bottomRight->originalPoint;
            chain_block[whichPiece]->topLeft->nextPoint=ToNext;
            chain_block[whichPiece-sizeCol-1]->bottomRight->nextPoint=beNext;
        }
    }
    if(whichPiece%sizeCol<sizeCol-1&&whichPiece/sizeCol>0&&chain_block[whichPiece]->topRight){
        if(!chain_block[whichPiece+1]->topLeft&&!chain_block[whichPiece-sizeCol]->bottomRight&&chain_block[whichPiece-sizeCol+1]->bottomLeft){
            chain_code_point* beNext = chain_block[whichPiece]->topRight->originalPoint;
            chain_code_point* ToNext = chain_block[whichPiece-sizeCol+1]->bottomLeft->originalPoint;
            chain_block[whichPiece]->topRight->nextPoint=ToNext;
            chain_block[whichPiece-sizeCol+1]->bottomLeft->nextPoint=beNext;
        }
    }
    if(whichPiece%sizeCol>0&&whichPiece/sizeCol<sizeRow-1&&chain_block[whichPiece]->bottomLeft&&chain_block[whichPiece+sizeCol-1]->topRight){
        if(!chain_block[whichPiece-1]->bottomRight&&!chain_block[whichPiece+sizeCol]->topLeft){
            chain_code_point* beNext = chain_block[whichPiece]->bottomLeft->originalPoint;
            chain_code_point* ToNext = chain_block[whichPiece+sizeCol-1]->topRight->originalPoint;
            chain_block[whichPiece]->bottomLeft->nextPoint=ToNext;
            chain_block[whichPiece+sizeCol-1]->topRight->nextPoint=beNext;
        }
    }
    if(whichPiece%sizeCol<sizeCol-1&&whichPiece/sizeCol<sizeRow-1&&chain_block[whichPiece]->bottomRight&&chain_block[whichPiece+sizeCol+1]->topLeft){
        if(!chain_block[whichPiece+1]->bottomLeft&&!chain_block[whichPiece+sizeCol]->topRight){
            chain_code_point* beNext = chain_block[whichPiece]->bottomRight->originalPoint;
            chain_code_point* ToNext = chain_block[whichPiece+sizeCol+1]->topLeft->originalPoint;
            chain_block[whichPiece]->bottomRight->nextPoint=ToNext;
            chain_block[whichPiece+sizeCol+1]->topLeft->nextPoint=beNext;
        }
    }
}


void modifyChainDirection(vector<int>& nodes,chain_code_point* chp,chain_code_point* mid){
    int a=-1;
    int b=-1;
    int c=-1;
    while (chp!=mid) {
        chp->goVisited=true;
        if(chp->nextPoint->x!=chp->x||chp->nextPoint->y!=chp->y){
            if(a==-1) a=getDirection(chp->type);
            else if(b==-1) b=getDirection(chp->type);
        }
        chp=chp->nextPoint;
    }
    if(a==0){
        if(b==2) c=1;
        if(b==6) c=7;
    }
    if(a==2){
        if(b==0) c=1;
        if(b==4) c=3;
    }
    if(a==4){
        if(b==2) c=3;
        if(b==6) c=5;
    }
    if(a==6){
        if(b==4) c=5;
        if(b==0) c=7;
    }
    nodes.push_back(c);
}

void processParallel(const vector<chain_code*>& vecs,int whichPiece,int row,int col){
    for (int j=0; j<vecs.size(); j++) {
        splitChainCode(vecs[j], whichPiece, row, col,j);
    }
    pthread_mutex_lock(&g_pmutex);
    chain_block[whichPiece]->status={1,1,1,1};
    pthread_mutex_unlock(&g_pmutex);
    if(whichPiece%sizeCol<sizeCol-1&&chain_block[whichPiece+1]->status[3]==1){
        pthread_mutex_lock(&g_pmutex);
        chain_block[whichPiece]->status[1]=0;
        chain_block[whichPiece+1]->status[3]=0;
        pthread_mutex_unlock(&g_pmutex);
        connectChainCode(whichPiece, whichPiece+1, 3);
    }
    if(whichPiece%sizeCol>0&&chain_block[whichPiece-1]->status[1]==1){
        pthread_mutex_lock(&g_pmutex);
        chain_block[whichPiece]->status[3]=0;
        chain_block[whichPiece-1]->status[1]=0;
        pthread_mutex_unlock(&g_pmutex);
        connectChainCode(whichPiece-1, whichPiece, 3);
    }
    if(whichPiece/sizeCol<sizeRow-1&&chain_block[whichPiece+sizeCol]->status[2]==1){
        pthread_mutex_lock(&g_pmutex);
        chain_block[whichPiece]->status[0]=0;
        chain_block[whichPiece+sizeCol]->status[2]=0;
        pthread_mutex_unlock(&g_pmutex);
        connectChainCode(whichPiece, whichPiece+sizeCol, 2);
    }
    if(whichPiece/sizeCol>0&&chain_block[whichPiece-sizeCol]->status[0]==1){
        pthread_mutex_lock(&g_pmutex);
        chain_block[whichPiece]->status[2]=0;
        chain_block[whichPiece-sizeCol]->status[0]=0;
        pthread_mutex_unlock(&g_pmutex);
        connectChainCode(whichPiece-sizeCol, whichPiece, 2);
    }    
}

void* threadAction(void* args){
    bool morePiece=true;
    int whichPiece = -1;
    while(morePiece){
        pthread_mutex_lock(&g_pmutex);
        if (processedPiece==numPiece) {
            morePiece=false;
            pthread_mutex_unlock(&g_pmutex);
        }
        else{
            whichPiece=processedPiece;
            processedPiece++;
            pthread_mutex_unlock(&g_pmutex);
            int row= (whichPiece/sizeCol+1) * PIECESIZE > rows ? (rows - whichPiece/sizeCol * PIECESIZE) : PIECESIZE;
            int col= (whichPiece%sizeCol+1) * PIECESIZE > cols ? (cols - whichPiece%sizeCol * PIECESIZE) : PIECESIZE;
            vector<chain_code*> vecs = extractChainCodesLevel(pieces[whichPiece],10);
            processParallel(vecs,whichPiece,row,col);
        }
    }
    pthread_exit(NULL);
}

vector<chain_code*> mergeChainCode(Mat& I){
    
    typedef chrono::high_resolution_clock clock;
    
    //    while(!chain_block.empty()){
    //        chain_block.pop_back();
    //    }
    
    vector<chain_code*> chain_code_result;
    rows=I.rows;
    cols=I.cols;
    sizeRow=ceil(rows/(double)PIECESIZE);
    sizeCol=ceil(cols/(double)PIECESIZE);
    for(int i=0;i<sizeRow;i++){
        for (int j=0; j<sizeCol; j++) {
            pieces.push_back(I(Range(i*PIECESIZE,((i+1)*PIECESIZE)>rows?rows:((i+1)*PIECESIZE)),Range(j*PIECESIZE,((j+1)*PIECESIZE)>cols?cols:((j+1)*PIECESIZE))));
        }
    }
    numPiece = (int) pieces.size();
    processedPiece = 0;
    for (int i=0; i<numPiece; i++) {
        chain_code_block* chb= new chain_code_block({0,0,0,0});
        for (int j=0; j<4; j++) {
            vector<chain_code_point*> vecp2;
            chb->border.push_back(vecp2);
        }
        chain_block.push_back(chb);
    }
    
    chrono::time_point<clock> start = clock::now();
    numthread=NUMTHR;
    printf("num of threads: %d\n",numthread);
    pthread_t* pth=new pthread_t[numthread];
    pthread_mutex_init(&g_pmutex, NULL);
    for (int i=0; i<numthread; i++){
        pthread_create(&pth[i], NULL, threadAction,NULL);
    }
    for (int i=0; i<numthread; i++){
        pthread_join(pth[i],NULL);
    }
    pthread_mutex_destroy(&g_pmutex);
    delete[] pth;
    chrono::time_point<clock> end1 = clock::now();
    printf("time to parallelize getting chain code:   %f\n",(double)std::chrono::duration_cast<std::chrono::milliseconds>(end1 - start).count());
//    for (int i=0; i<sizeRow; i++) {
//        for (int j=0; j<sizeCol-1; j++) {
//            connectChainCode(i*sizeCol+j, i*sizeCol+j+1, 3);
//        }
//    }
//    
//    for (int i=0; i<sizeCol; i++) {
//        for (int j=0; j<sizeRow-1; j++) {
//            connectChainCode(j*sizeCol+i, (j+1)*sizeCol+i, 2);
//        }
//    }
    
    for (int i=0; i<numPiece; i++) {
        compareCorner(i);
    }
    
    for (int i=0; i<chain_block.size(); i++) {
        vector<chain_code*>& vec=chain_block[i]->unbounded;
        for (int j=0; j<vec.size(); j++) {
            vec[j]->x += i/sizeCol * PIECESIZE;
            vec[j]->y += i%sizeCol * PIECESIZE;
            chain_code_result.push_back(vec[j]);
        }
    }
    
    
    for (int i=0; i<chain_block.size(); i++) {
        vector<chain_code_point*>& vec=chain_block[i]->bounded;
        for (int j=0; j<vec.size(); j++) {
            chain_code_point* start=vec[j];
            if(!start->goVisited){                
                if(checkForSpecialPoint(start)==1) continue;
                chain_code_point* start_cpy=start;
                do{
                    if(start->next) start=start->next->next;
                    else start=start->nextPoint;
                }while(start!=start_cpy&&start->cornerType>3);
                int x = start->x + start->whichPiece/sizeCol * PIECESIZE;
                int y = start->y + start->whichPiece%sizeCol * PIECESIZE;
                chain_code* ch= new chain_code(x,y);
                chain_code_point* chp=start;
                vector<int> node;
                do{
                    
                    if(chp->next){
                        for (int r=0; r<chp->next->node.size();r++) {
                            node.push_back(chp->next->node[r]);
                        }
                        chp->goVisited=true;
                        chp=chp->next->next;
                        
                    }
                    else{
                        chain_code_point* mid=NULL;
                        if((mid=checkForSpecialPoint2(chp))){
                            modifyChainDirection(node,chp,mid);
                            chp=mid;
                        }
                        chain_code_point* nextOne=chp->nextPoint;
                        int s1=startPoint(chp);
                        int s2=startPoint(nextOne);
                        if(chp->x!=nextOne->x||chp->y!=nextOne->y){
                            if(chp->whichPiece!=nextOne->whichPiece){
                                if(checkOppAngle(chp->whichPiece,chp->nextPoint->whichPiece,sizeCol)){
                                    if(chp->type==2) node.push_back(1);
                                    if(chp->type==0) node.push_back(5);
                                    if(chp->type==1) node.push_back(7);
                                    if(chp->type==3) node.push_back(3);
                                }
                                else if(s1!=s2){
                                    if( (s1<s2 && (chp->type==0||chp->type==3)) || (s1>s2 && (chp->type==1||chp->type==2)) ){
                                        node.push_back(getDirectionMove2(chp->type,s1>s2));
                                        for (int s=1; s<abs(s2-s1); s++) {
                                            node.push_back(getDirectionMove(chp->type,s1>s2));
                                        }
                                    }
                                    else {
                                        for (int s=1; s<abs(s2-s1); s++) {
                                            node.push_back(getDirectionMove(chp->type,s1>s2));
                                        }
                                        node.push_back(getDirectionMove2(chp->type,s1>s2));
                                    }
                                }
                                else{
                                    node.push_back(getDirection(chp->type));
                                }
                            }
                            else{
                                if(chp->special){
                                    if(abs(s2-s1)>1){
                                        node.push_back(getDirectionMove2(chp->type,s1>s2));
                                        for (int s=0; s<abs(s2-s1)-2 ; s++) {
                                            node.push_back(getDirectionMove(chp->type,s1>s2));
                                        }
                                        node.push_back(getDirectionMove3(chp->type,s1>s2));
                                    }
                                    else{
                                        node.push_back(getDirectionMove(chp->type,s1>s2));
                                    }
                                }
                                else{
                                    for (int s=0; s<abs(s2-s1); s++) {
                                        node.push_back(getDirectionMove(chp->type,s1>s2));
                                    }
                                }
                            }
                        }
                        chp->goVisited=true;
                        chp=chp->nextPoint;
                    }
                } while(chp!=start);
                ch->nodes=node;
                chain_code_result.push_back(ch);
            }
        }
    }
    
    for (int i=0; i<chain_block.size(); i++) {
        vector<chain_code_point*>& vec=chain_block[i]->begins;
        for (int j=0; j<vec.size(); j++) {
            chain_code_point* start=vec[j];
            if(!start->goVisited){
                if(checkForSpecialPoint(start)==1) continue;
                chain_code_point* start_cpy=start;
                do{
                    if(start->next) start=start->next->next;
                    else start=start->nextPoint;
                }while(start!=start_cpy&&start->cornerType>3);
                int x = start->x + start->whichPiece/sizeCol * PIECESIZE;
                int y = start->y + start->whichPiece%sizeCol * PIECESIZE;
                chain_code* ch= new chain_code(x,y);
                chain_code_point* chp=start;               
                vector<int> node;
                do{
                    if(chp->next){
                        for (int r=0; r<chp->next->node.size();r++) {
                            node.push_back(chp->next->node[r]);
                        }
                        chp->goVisited=true;
                        chp=chp->next->next;
                    }
                    else{
                        chain_code_point* mid=NULL;
                        if((mid=checkForSpecialPoint2(chp))){
                            modifyChainDirection(node,chp,mid);
                            chp=mid;
                        }
                        chain_code_point* nextOne=chp->nextPoint;
                        int s1=startPoint(chp);
                        int s2=startPoint(nextOne);
                        if(chp->x!=nextOne->x||chp->y!=nextOne->y){
                            if(chp->whichPiece!=nextOne->whichPiece){
                                if(checkOppAngle(chp->whichPiece,chp->nextPoint->whichPiece,sizeCol)){
                                    if(chp->type==2) node.push_back(1);
                                    if(chp->type==0) node.push_back(5);
                                    if(chp->type==1) node.push_back(7);
                                    if(chp->type==3) node.push_back(3);
                                }
                                else if(s1!=s2){
                                    if( (s1<s2 && (chp->type==0||chp->type==3)) || (s1>s2 && (chp->type==1||chp->type==2)) ){
                                        node.push_back(getDirectionMove2(chp->type,s1>s2));
                                        for (int s=1; s<abs(s2-s1); s++) {
                                            node.push_back(getDirectionMove(chp->type,s1>s2));
                                        }
                                    }
                                    else {
                                        for (int s=1; s<abs(s2-s1); s++) {
                                            node.push_back(getDirectionMove(chp->type,s1>s2));
                                        }
                                        node.push_back(getDirectionMove2(chp->type,s1>s2));
                                    }
                                }
                                else{
                                    node.push_back(getDirection(chp->type));
                                }
                            }
                            else{
                                if(chp->special){
                                    if(abs(s2-s1)>1){
                                        node.push_back(getDirectionMove2(chp->type,s1>s2));
                                        for (int s=0; s<abs(s2-s1)-2; s++) {
                                            node.push_back(getDirectionMove(chp->type,s1>s2));
                                        }
                                        node.push_back(getDirectionMove3(chp->type,s1>s2));
                                    }
                                    else{
                                        node.push_back(getDirectionMove(chp->type,s1>s2));
                                    }
                                }
                                else{
                                    for (int s=0; s<abs(s2-s1); s++) {
                                        node.push_back(getDirectionMove(chp->type,s1>s2));
                                    }
                                }
                            }
                        }
                        chp->goVisited=true;
                        chp=chp->nextPoint;
                    }
                } while(chp!=start);
                ch->nodes=node;
                chain_code_result.push_back(ch);
            }
        }
    }
    chrono::time_point<clock> end2 = clock::now();
    printf("time to go through to get chain code:   %f \n\n\n",(double)std::chrono::duration_cast<std::chrono::milliseconds>(end2 - end1).count());
    return chain_code_result;
}








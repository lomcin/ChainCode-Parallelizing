//
//  main.cpp
//  OpenTest
//
//  Created by Yun on 10/4/15.
//  Copyright Â© 2015 Yun. All rights reserved.
//


#include <dirent.h>
#include <iostream>

#include "MergeChainCode.hpp"


void Test(){
    const char * dir = "/Users/yun/Documents/Capstone/images/";
    DIR * d;
    char* dir_copy;
    d=opendir(dir);
    int numFiles=0;
    while (struct dirent* entry=readdir(d)) {
        if(strcmp(entry->d_name,".")&&strcmp(entry->d_name,"..")&&strcmp(entry->d_name,".DS_Store")){
            (numFiles)++;
        }
    }
    closedir(d);
    
    d=opendir(dir);
    char ** filenames = (char **) malloc(sizeof(char *) * (numFiles));
    int i=0;
    while(struct dirent* entry=readdir(d)) {
        if(strcmp(entry->d_name,".")&&strcmp(entry->d_name,"..")&&strcmp(entry->d_name,".DS_Store")){
            dir_copy=(char*) malloc(sizeof(char) * (strlen(dir) + strlen(entry->d_name)+1));
            memcpy(dir_copy, dir,strlen(dir)+1);
            strcat(dir_copy, entry->d_name);
            (filenames)[i] = (char*) malloc( sizeof(char) *(strlen(dir_copy)+1) );
            memcpy((filenames)[i], dir_copy,(strlen(dir_copy)+1));
            ((filenames)[i])[strlen(dir_copy)]='\0';
            i++;
        }
    }
    closedir(d);
    
    for (int i=0; i<numFiles; i++) {
        Mat img = imread(filenames[i],CV_LOAD_IMAGE_GRAYSCALE);
        Mat I;
        threshold(img, I, THRESHOLDVALUE, 255, CV_THRESH_BINARY);
        cout<<filenames[i]<<":"<<endl;
        
        vector<chain_code*> result= mergeChainCode(I);
        Mat II= toImage(result,I.rows,I.cols);
        
        vector<chain_code*> vecc=extractChainCodes(I);
        Mat expect = toImage(vecc, I.rows, I.cols);
        
        for(int i=0;i<I.rows;i++){
            for (int j=0; j<I.cols; j++) {
                if(expect.at<uchar>(i,j)!=II.at<uchar>(i,j)){
                    cout<<"("<<i<<","<<j<<")--";
                }
            }
        }
        cout<<endl<<"end this picture"<<endl<<endl<<endl;
    }
}


void Test2(){
        Mat img = imread("/Users/yun/Study/Capstone/images/70mp/gameofthrones15_172.jpg",CV_LOAD_IMAGE_GRAYSCALE);
        Mat I;
        threshold(img, I, THRESHOLDVALUE, 255, CV_THRESH_BINARY);
    //
    //
        imwrite( "/Users/yun/Study/Capstone/testing/Origin.jpg", I );
//        string window_name = "Origin Iamge";
//        namedWindow( window_name, CV_WINDOW_AUTOSIZE );
//        imshow( window_name,I);
//        waitKey(0);
    //
    typedef chrono::high_resolution_clock clock;
    chrono::time_point<clock> start = clock::now();
    vector<chain_code*> result= mergeChainCode(I);
    //printChainCode(result);
    double tt1 = (double)std::chrono::duration_cast<std::chrono::milliseconds>(clock::now() - start).count();
    printf("time of whole parallel algorithm:   %f\n",tt1);
    //Mat II= toImage(result,I.rows,I.cols);
    
        //imwrite( "/Users/yun/Study/Capstone/testing/Parallel.jpg", II );
//        string window_name2 = "result Iamge";
//        namedWindow( window_name2, CV_WINDOW_AUTOSIZE );
//        imshow( window_name2,II);
//        waitKey(0);
    
        typedef chrono::high_resolution_clock clock;
        chrono::time_point<clock> start2 = clock::now();
        vector<chain_code*> vecc=extractChainCodes(I);
        //printChainCode(vecc);
    double tt2 = (double)std::chrono::duration_cast<std::chrono::milliseconds>(clock::now() - start2).count();
        printf("time of original algorithm:   %f\n",tt2);
    //double tt2 = 57000.00;
    
        printf("speedup:   %f\n",tt2/tt1);
        //Mat expect = toImage(vecc, I.rows, I.cols);
            //imwrite( "/Users/yun/Study/Capstone/testing/Series.jpg", expect);
//            string window_name3 = "Expect Iamge";
//            namedWindow( window_name3, CV_WINDOW_AUTOSIZE );
//            imshow( window_name3,expect);
//            waitKey(0);
    
    
    
//        for(int i=0;i<I.rows;i++){
//            for (int j=0; j<I.cols; j++) {
//                if(expect.at<uchar>(i,j)!=II.at<uchar>(i,j)){
//                    cout<<"("<<i<<","<<j<<")--";
//                }
//            }
//        }
//        cout<<endl;
    
}

void Test3(){
   Mat I(2000,2000,CV_8UC(1),BACKGROUND);
    

    
//    Testing 2
//    for(int i=0;i<500;i++){
//        for(int j=0;j<500;j++){
//            if( (i%256==0||i%256==255) && (j%256==0||j%256==255) ){
//                I.at<uchar>(i,j)=FOREGROUND;
//            }
//        }
//    }
    
    
    // Testing 3
//        for(int i=0;i<2000;i++){
//            for(int j=0;j<2000;j++){
//                if( (i%256==0&&j%256==0) || (i%256==255&&j%256==255) ){
//                    I.at<uchar>(i,j)=FOREGROUND;
//                }
//            }
//        }
    
    
    
//    for(int i=0;i<2000;i++){
//        for(int j=0;j<2000;j++){
//            if( (i%256+j%256<128)|| (j%256==0) ||(i%256==0) ){
//                I.at<uchar>(i,j)=FOREGROUND;
//            }
//        }
//    }
    
    // Testing 4
//    for(int i=0;i<2000;i++){
//        for(int j=0;j<2000;j++){
//            if( (i%256>=abs(j%256-128)+256-80)||(i%256==255)||(j%256>=abs(i%256-128)+256-80)||(j%256==255)){
//                I.at<uchar>(i,j)=FOREGROUND;
//            }
//        }
//    }

    
    // Testing 5
    for(int i=0;i<2000;i++){
        for (int j=0; j<1000; j++) {
            if(i%2){
                I.at<uchar>(j*2,i)=FOREGROUND;
            }
            else{
                I.at<uchar>(j*2+1,i)=FOREGROUND;
            }
        }
    }
    
//    for(int i=0;i<2000;i++){
//        for (int j=0; j<500; j++) {
//            if(i%4){
//                I.at<uchar>(i,j*4+2)=FOREGROUND;
//            }
//            else{
//                I.at<uchar>(i,j*4+2+ ((i%4)<3?(i%4):1) )=FOREGROUND;
//                I.at<uchar>(i,j*4+2- ((i%4)<3?(i%4):1) )=FOREGROUND;
//            }
//        }
//    }
    
    
//    Mat I(1001,1001,CV_8UC(1),BACKGROUND);
//    
//    for(int i=0;i<501;i++){
//        for (int j=0; j<2*i+1; j=j+2) {
//            I.at<uchar>(i,500-i+j)=FOREGROUND;
//        }
//    }
//    for(int i=501;i<1001;i++){
//        for (int j=0; j<2*(1000-i)+1; j=j+2) {
//            I.at<uchar>(i,i-500+j)=FOREGROUND;
//        }
//    }

    imwrite( "/Users/yun/Study/Capstone/testing/Origin2.jpg", I);
    typedef chrono::high_resolution_clock clock;
    chrono::time_point<clock> start = clock::now();
    vector<chain_code*> result= mergeChainCode(I);
    printf("time of whole parallel algorithm:   %f\n",(double)std::chrono::duration_cast<std::chrono::milliseconds>(clock::now() - start).count());
    Mat II= toImage(result,I.rows,I.cols);
    imwrite( "/Users/yun/Study/Capstone/testing/Parallel2.jpg", II);
    //printChainCode(result);
//    string window_name2 = "Result Iamge";
//    namedWindow( window_name2, CV_WINDOW_AUTOSIZE );
//    imshow( window_name2,II);
//    waitKey(0);
    
    chrono::time_point<clock> end = clock::now();
    vector<chain_code*> vecc=extractChainCodes(I);
     printf("time of original algorithm:   %f\n",(double)std::chrono::duration_cast<std::chrono::milliseconds>(clock::now() - end).count());
    //printChainCode(vecc);
    Mat expect = toImage(vecc, I.rows, I.cols);
    imwrite( "/Users/yun/Study/Capstone/testing/Series2.jpg", expect);
//    string window_name3 = "Expect Iamge";
//    namedWindow( window_name3, CV_WINDOW_AUTOSIZE );
//    imshow( window_name3,expect);
//    waitKey(0);
    
    
    
    for(int i=0;i<I.rows;i++){
        for (int j=0; j<I.cols; j++) {
            if(expect.at<uchar>(i,j)!=II.at<uchar>(i,j)){
                cout<<"("<<i<<","<<j<<")--";
            }
        }
    }
    cout<<endl;
}


int main(int argc, const char * argv[])
{
    Test2();
    
    //Test3();
    
    //    Mat imgROI = expect(Rect(1274,505,12,12));
    //    cout<<imgROI<<endl<<endl;
    //
    //    Mat imgROI2 = II(Rect(1274,505,12,12));
    //    cout<<imgROI2<<endl<<endl;
    //
    
    return 0;
}

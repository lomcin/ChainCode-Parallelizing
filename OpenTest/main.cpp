//
//  main.cpp
//  OpenTest
//
//  Created by Yun on 10/4/15.
//  Copyright Â© 2015 Yun. All rights reserved.
//



#include <iostream>
#include <dirent.h>

#include "GetChainCode.hpp"
#include "MergeChainCode.hpp"


void Test(){
    const char * dir = "/Users/yun/Documents/Capstone/images/";
    DIR * d;
    char* dir_copy;
    struct dirent* entry;
    d=opendir(dir);
    int numFiles=0;
    while ((entry=readdir(d))) {
        if(strcmp(entry->d_name,".")&&strcmp(entry->d_name,"..")&&strcmp(entry->d_name,".DS_Store")){
            (numFiles)++;
        }
    }
    closedir(d);
    
    d=opendir(dir);
    char ** filenames = (char **) malloc(sizeof(char *) * (numFiles));
    int i=0;
    while((entry=readdir(d))) {
        if(strcmp(entry->d_name,".")&&strcmp(entry->d_name,"..")&&strcmp(entry->d_name,".DS_Store")){
            dir_copy=(char*) malloc(sizeof(char) * (strlen(dir) + strlen(entry->d_name)+1));
            memcpy(dir_copy, dir,strlen(dir)+1);
            strcat(dir_copy, entry->d_name);
            (filenames)[i] = (char*) malloc( sizeof(char) *(strlen(dir_copy)+1) );
            memcpy((filenames)[i], dir_copy,(strlen(dir_copy)+1));
            ((filenames)[i])[strlen(dir_copy)]='\0';
            i++;
        }
    }
    closedir(d);
    
    for (int i=0; i<numFiles; i++) {
        Mat img = imread(filenames[i],CV_LOAD_IMAGE_GRAYSCALE);
        Mat I;
        threshold(img, I, THRESHOLDVALUE, 255, CV_THRESH_BINARY);
        cout<<filenames[i]<<":"<<endl;
        
        vector<chain_code*> result= mergeChainCode(I);
        Mat II= toImage(result,I.rows,I.cols);
        
        vector<chain_code*> *vecc=extractChainCodes2(&I);
        Mat expect = toImage(*vecc, I.rows, I.cols);
        
        for(int i=0;i<I.rows;i++){
            for (int j=0; j<I.cols; j++) {
                if(expect.at<uchar>(i,j)!=II.at<uchar>(i,j)){
                    cout<<"("<<i<<","<<j<<")--";
                }
            }
        }
        cout<<endl<<"end this picture"<<endl<<endl<<endl;
    }
}


void Test2(){
        Mat img = imread("/Users/yun/Documents/Capstone/images/artsfon.com-22311.jpg",CV_LOAD_IMAGE_GRAYSCALE);
        Mat I;
        threshold(img, I, THRESHOLDVALUE, 255, CV_THRESH_BINARY);
    //
    //
    ////    string window_name = "Origin Iamge";
    ////    namedWindow( window_name, CV_WINDOW_AUTOSIZE );
    ////    imshow( window_name,I);
    ////    waitKey(0);
    //
    typedef chrono::high_resolution_clock clock;
    chrono::time_point<clock> start = clock::now();
    vector<chain_code*> result= mergeChainCode(I);
    //printChainCode(result);
    printf("time of whole parallel algorithm:   %f\n",(double)std::chrono::duration_cast<std::chrono::milliseconds>(clock::now() - start).count());
    Mat II= toImage(result,I.rows,I.cols);
    
    //    string window_name2 = "result Iamge";
    //    namedWindow( window_name2, CV_WINDOW_AUTOSIZE );
    //    imshow( window_name2,II);
    //    waitKey(0);
    
        typedef chrono::high_resolution_clock clock;
        chrono::time_point<clock> start2 = clock::now();
        vector<chain_code*> *vecc=extractChainCodes2(&I);
        //printChainCode(*vecc);
        printf("time of original algorithm:   %f\n",(double)std::chrono::duration_cast<std::chrono::milliseconds>(clock::now() - start2).count());
        Mat expect = toImage(*vecc, I.rows, I.cols);
        //    string window_name3 = "Expect Iamge";
        //    namedWindow( window_name3, CV_WINDOW_AUTOSIZE );
        //    imshow( window_name3,expect);
        //    waitKey(0);
    
    
    
        for(int i=0;i<I.rows;i++){
            for (int j=0; j<I.cols; j++) {
                if(expect.at<uchar>(i,j)!=II.at<uchar>(i,j)){
                    cout<<"("<<i<<","<<j<<")--";
                }
            }
        }
        cout<<endl;
    
}

void Test3(){
    Mat I(2000,2000,CV_8UC(1),BACKGROUND);
    
    for(int i=0;i<2000;i++){
        for (int j=0; j<1000; j++) {
            if(i%2){
                I.at<uchar>(i,j*2)=FOREGROUND;
            }
            else{
                I.at<uchar>(i,j*2+1)=FOREGROUND;
            }
        }
    }
    
    typedef chrono::high_resolution_clock clock;
    chrono::time_point<clock> start = clock::now();
    vector<chain_code*> result= mergeChainCode(I);
    printf("time of whole parallel algorithm:   %f\n",(double)std::chrono::duration_cast<std::chrono::milliseconds>(clock::now() - start).count());
    Mat II= toImage(result,I.rows,I.cols);
    //printChainCode(*vecc);
    string window_name2 = "Result Iamge";
    namedWindow( window_name2, CV_WINDOW_AUTOSIZE );
    imshow( window_name2,II);
    waitKey(0);
    
    chrono::time_point<clock> end = clock::now();
    vector<chain_code*> *vecc=extractChainCodes2(&I);
     printf("time of original algorithm:   %f\n",(double)std::chrono::duration_cast<std::chrono::milliseconds>(clock::now() - end).count());
    //printChainCode(*vecc);
    Mat expect = toImage(*vecc, I.rows, I.cols);
    string window_name3 = "Expect Iamge";
    namedWindow( window_name3, CV_WINDOW_AUTOSIZE );
    imshow( window_name3,expect);
    waitKey(0);
    
    
    
    for(int i=0;i<I.rows;i++){
        for (int j=0; j<I.cols; j++) {
            if(expect.at<uchar>(i,j)!=II.at<uchar>(i,j)){
                cout<<"("<<i<<","<<j<<")--";
            }
        }
    }
    cout<<endl;
}


int main(int argc, const char * argv[])
{
    Test2();
    //Test3();
    
    //    Mat imgROI = expect(Rect(1274,505,12,12));
    //    cout<<imgROI<<endl<<endl;
    //
    //    Mat imgROI2 = II(Rect(1274,505,12,12));
    //    cout<<imgROI2<<endl<<endl;
    //
    
    return 0;
}

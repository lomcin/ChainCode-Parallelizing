//
//  main.cpp
//  OpenTest
//
//  Created by Yun on 10/4/15.
//  Copyright Â© 2015 Yun. All rights reserved.
//



#include <iostream>
#include <dirent.h>

#include "GetChainCode.hpp"
#include "MergeChainCode.hpp"


void Test(){
    const char * dir = "/Users/yun/Documents/Capstone/images/";
    DIR * d;
    char* dir_copy;
    struct dirent* entry;
    d=opendir(dir);
    int numFiles=0;
    while ((entry=readdir(d))) {
        if(strcmp(entry->d_name,".")&&strcmp(entry->d_name,"..")&&strcmp(entry->d_name,".DS_Store")){
            (numFiles)++;
        }
    }
    closedir(d);
    
    d=opendir(dir);
    char ** filenames = (char **) malloc(sizeof(char *) * (numFiles));
    int i=0;
    while((entry=readdir(d))) {
        if(strcmp(entry->d_name,".")&&strcmp(entry->d_name,"..")&&strcmp(entry->d_name,".DS_Store")){
            dir_copy=(char*) malloc(sizeof(char) * (strlen(dir) + strlen(entry->d_name)+1));
            memcpy(dir_copy, dir,strlen(dir)+1);
            strcat(dir_copy, entry->d_name);
            (filenames)[i] = (char*) malloc( sizeof(char) *(strlen(dir_copy)+1) );
            memcpy((filenames)[i], dir_copy,(strlen(dir_copy)+1));
            ((filenames)[i])[strlen(dir_copy)]='\0';
            i++;
        }
    }
    closedir(d);
    
    for (int i=0; i<numFiles; i++) {
        Mat img = imread(filenames[i],CV_LOAD_IMAGE_GRAYSCALE);
        Mat I;
        threshold(img, I, THRESHOLDVALUE, 255, CV_THRESH_BINARY);
        cout<<filenames[i]<<":"<<endl;
        
        vector<chain_code*> result= mergeChainCode(I);
        Mat II= toImage(result,I.rows,I.cols);
        
        vector<chain_code*> *vecc=extractChainCodesF2(&I);
        Mat expect = toImage(*vecc, I.rows, I.cols);
        
        for(int i=0;i<I.rows;i++){
            for (int j=0; j<I.cols; j++) {
                if(expect.at<uchar>(i,j)!=II.at<uchar>(i,j)){
                    cout<<"("<<i<<","<<j<<")--";
                }
            }
        }
        cout<<endl<<"end this picture"<<endl<<endl<<endl;
    }
}


void Test2(){
        Mat img = imread("/Users/yun/Documents/Capstone/images/7a155e60-ca62-4dd1-8daf-457c93d65cf3.jpg",CV_LOAD_IMAGE_GRAYSCALE);
        Mat I;
        threshold(img, I, THRESHOLDVALUE, 255, CV_THRESH_BINARY);
    //
    //
    ////    string window_name = "Origin Iamge";
    ////    namedWindow( window_name, CV_WINDOW_AUTOSIZE );
    ////    imshow( window_name,I);
    ////    waitKey(0);
    //
    
        vector<chain_code*> result= mergeChainCode(I);
        //printChainCode(result);
        Mat II= toImage(result,I.rows,I.cols);
    
    //    string window_name2 = "result Iamge";
    //    namedWindow( window_name2, CV_WINDOW_AUTOSIZE );
    //    imshow( window_name2,II);
    //    waitKey(0);
    
    
        vector<chain_code*> *vecc=extractChainCodes2(&I);
        //printChainCode(*vecc);
        Mat expect = toImage(*vecc, I.rows, I.cols);
        //    string window_name3 = "Expect Iamge";
        //    namedWindow( window_name3, CV_WINDOW_AUTOSIZE );
        //    imshow( window_name3,expect);
        //    waitKey(0);
    
    
    
        for(int i=0;i<I.rows;i++){
            for (int j=0; j<I.cols; j++) {
                if(expect.at<uchar>(i,j)!=II.at<uchar>(i,j)){
                    cout<<"("<<i<<","<<j<<")--";
                }
            }
        }
        cout<<endl;
    
    
    //    Mat imgROI = expect(Rect(1274,505,12,12));
    //    cout<<imgROI<<endl<<endl;
    //    
    //    Mat imgROI2 = II(Rect(1274,505,12,12));
    //    cout<<imgROI2<<endl<<endl;
    //
}


int main(int argc, const char * argv[])
{
    //Test2();
    
    Mat I(1000,1000,CV_8UC(1),BACKGROUND);
    
            for(int i=0;i<1000;i++){
                for (int j=0; j<500; j++) {
                    if(i%2){
                        I.at<uchar>(i,j*2)=FOREGROUND;
                    }
                    else{
                        I.at<uchar>(i,j*2+1)=FOREGROUND;
                    }
                }
            }
//    I.at<uchar>(255,255)=FOREGROUND;
//    I.at<uchar>(255,256)=FOREGROUND;
//    I.at<uchar>(256,256)=FOREGROUND;
//    I.at<uchar>(256,255)=FOREGROUND;
    vector<chain_code*> result= mergeChainCode(I);
    Mat II= toImage(result,I.rows,I.cols);
    //printChainCode(*vecc);
    string window_name2 = "Result Iamge";
    namedWindow( window_name2, CV_WINDOW_AUTOSIZE );
    imshow( window_name2,II);
    waitKey(0);
    
    
    vector<chain_code*> *vecc=extractChainCodes2(&I);
    //printChainCode(*vecc);
        Mat expect = toImage(*vecc, I.rows, I.cols);
        string window_name3 = "Expect Iamge";
        namedWindow( window_name3, CV_WINDOW_AUTOSIZE );
        imshow( window_name3,expect);
        waitKey(0);
    
    
    
    for(int i=0;i<I.rows;i++){
        for (int j=0; j<I.cols; j++) {
            if(expect.at<uchar>(i,j)!=II.at<uchar>(i,j)){
                cout<<"("<<i<<","<<j<<")--";
            }
        }
    }
    cout<<endl;

    
    //    Mat imgROI = expect(Rect(1274,505,12,12));
    //    cout<<imgROI<<endl<<endl;
    //
    //    Mat imgROI2 = II(Rect(1274,505,12,12));
    //    cout<<imgROI2<<endl<<endl;
    //
    
    return 0;
}

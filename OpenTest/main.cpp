//
//  main.cpp
//  OpenTest
//
//  Created by Yun on 10/4/15.
//  Copyright Â© 2015 Yun. All rights reserved.
//


#include <dirent.h>
#include <iostream>

#include "MergeChainCode.hpp"


void Test(){
    const char * dir = "/Users/yun/Documents/Capstone/images/";
    DIR * d;
    char* dir_copy;
    d=opendir(dir);
    int numFiles=0;
    while (struct dirent* entry=readdir(d)) {
        if(strcmp(entry->d_name,".")&&strcmp(entry->d_name,"..")&&strcmp(entry->d_name,".DS_Store")){
            (numFiles)++;
        }
    }
    closedir(d);
    
    d=opendir(dir);
    char ** filenames = (char **) malloc(sizeof(char *) * (numFiles));
    int i=0;
    while(struct dirent* entry=readdir(d)) {
        if(strcmp(entry->d_name,".")&&strcmp(entry->d_name,"..")&&strcmp(entry->d_name,".DS_Store")){
            dir_copy=(char*) malloc(sizeof(char) * (strlen(dir) + strlen(entry->d_name)+1));
            memcpy(dir_copy, dir,strlen(dir)+1);
            strcat(dir_copy, entry->d_name);
            (filenames)[i] = (char*) malloc( sizeof(char) *(strlen(dir_copy)+1) );
            memcpy((filenames)[i], dir_copy,(strlen(dir_copy)+1));
            ((filenames)[i])[strlen(dir_copy)]='\0';
            i++;
        }
    }
    closedir(d);
    
    for (int i=0; i<numFiles; i++) {
        Mat img = imread(filenames[i],CV_LOAD_IMAGE_GRAYSCALE);
        Mat I;
        threshold(img, I, THRESHOLDVALUE, 255, CV_THRESH_BINARY);
        cout<<filenames[i]<<":"<<endl;
        
        vector<chain_code*> result= mergeChainCode(I);
        Mat II= toImage(result,I.rows,I.cols);
        
        vector<chain_code*> vecc=extractChainCodes(I);
        Mat expect = toImage(vecc, I.rows, I.cols);
        
        for(int i=0;i<I.rows;i++){
            for (int j=0; j<I.cols; j++) {
                if(expect.at<uchar>(i,j)!=II.at<uchar>(i,j)){
                    cout<<"("<<i<<","<<j<<")--";
                }
            }
        }
        cout<<endl<<"end this picture"<<endl<<endl<<endl;
    }
}


void Test2(){
        Mat img = imread("/Users/yun/Study/Capstone/images/7a155e60-ca62-4dd1-8daf-457c93d65cf3.jpg",CV_LOAD_IMAGE_GRAYSCALE);
        Mat I;
        threshold(img, I, THRESHOLDVALUE, 255, CV_THRESH_BINARY);
    //
    //
//        string window_name = "Origin Iamge";
//        namedWindow( window_name, CV_WINDOW_AUTOSIZE );
//        imshow( window_name,I);
//        waitKey(0);
    //
    typedef chrono::high_resolution_clock clock;
    chrono::time_point<clock> start = clock::now();
    vector<chain_code*> result= mergeChainCode(I);
    //printChainCode(result);
    printf("time of whole parallel algorithm:   %f\n",(double)std::chrono::duration_cast<std::chrono::milliseconds>(clock::now() - start).count());
    Mat II= toImage(result,I.rows,I.cols);
    
//        string window_name2 = "result Iamge";
//        namedWindow( window_name2, CV_WINDOW_AUTOSIZE );
//        imshow( window_name2,II);
//        waitKey(0);
    
        typedef chrono::high_resolution_clock clock;
        chrono::time_point<clock> start2 = clock::now();
        vector<chain_code*> vecc=extractChainCodesLevel(I,10);
        //printChainCode(*vecc);
        printf("time of original algorithm:   %f\n",(double)std::chrono::duration_cast<std::chrono::milliseconds>(clock::now() - start2).count());
        Mat expect = toImage(vecc, I.rows, I.cols);
            string window_name3 = "Expect Iamge";
            namedWindow( window_name3, CV_WINDOW_AUTOSIZE );
            imshow( window_name3,expect);
            waitKey(0);
    
    
    
        for(int i=0;i<I.rows;i++){
            for (int j=0; j<I.cols; j++) {
                if(expect.at<uchar>(i,j)!=II.at<uchar>(i,j)){
                    cout<<"("<<i<<","<<j<<")--";
                }
            }
        }
        cout<<endl;
    
}

void Test3(){
    Mat I(1000,1000,CV_8UC(1),BACKGROUND);
    
    
    
//    for(int i=0;i<2000;i++){
//        for(int j=0;j<2000;j++){
//            if( (i%256==0&&j%256==0) || (i%256==255&&j%256==255) ){
//                I.at<uchar>(i,j)=FOREGROUND;
//            }
//        }
//    }

    for(int i=0;i<1000;i++){
        for(int j=0;j<1000;j++){
            if( (i%256==0||i%256==255) && (j%256==0||j%256==255) ){
                I.at<uchar>(i,j)=FOREGROUND;
            }
        }
    }
    
//    for(int i=0;i<2000;i++){
//        for (int j=0; j<1000; j++) {
//            if(i%2){
//                I.at<uchar>(i,j*2)=FOREGROUND;
//            }
//            else{
//                I.at<uchar>(i,j*2+1)=FOREGROUND;
//            }
//        }
//    }
    
//    for(int i=0;i<2000;i++){
//        for (int j=0; j<500; j++) {
//            if(i%4){
//                I.at<uchar>(i,j*4+2)=FOREGROUND;
//            }
//            else{
//                I.at<uchar>(i,j*4+2+ ((i%4)<3?(i%4):1) )=FOREGROUND;
//                I.at<uchar>(i,j*4+2- ((i%4)<3?(i%4):1) )=FOREGROUND;
//            }
//        }
//    }
    
    
//    Mat I(1001,1001,CV_8UC(1),BACKGROUND);
//    
//    for(int i=0;i<501;i++){
//        for (int j=0; j<2*i+1; j=j+2) {
//            I.at<uchar>(i,500-i+j)=FOREGROUND;
//        }
//    }
//    for(int i=501;i<1001;i++){
//        for (int j=0; j<2*(1000-i)+1; j=j+2) {
//            I.at<uchar>(i,i-500+j)=FOREGROUND;
//        }
//    }

    
    typedef chrono::high_resolution_clock clock;
    chrono::time_point<clock> start = clock::now();
    vector<chain_code*> result= mergeChainCode(I);
    printf("time of whole parallel algorithm:   %f\n",(double)std::chrono::duration_cast<std::chrono::milliseconds>(clock::now() - start).count());
    Mat II= toImage(result,I.rows,I.cols);
    //printChainCode(result);
    string window_name2 = "Result Iamge";
    namedWindow( window_name2, CV_WINDOW_AUTOSIZE );
    imshow( window_name2,II);
    waitKey(0);
    
    chrono::time_point<clock> end = clock::now();
    vector<chain_code*> vecc=extractChainCodes(I);
     printf("time of original algorithm:   %f\n",(double)std::chrono::duration_cast<std::chrono::milliseconds>(clock::now() - end).count());
    //printChainCode(*vecc);
    Mat expect = toImage(vecc, I.rows, I.cols);
    string window_name3 = "Expect Iamge";
    namedWindow( window_name3, CV_WINDOW_AUTOSIZE );
    imshow( window_name3,expect);
    waitKey(0);
    
    
    
    for(int i=0;i<I.rows;i++){
        for (int j=0; j<I.cols; j++) {
            if(expect.at<uchar>(i,j)!=II.at<uchar>(i,j)){
                cout<<"("<<i<<","<<j<<")--";
            }
        }
    }
    cout<<endl;
}


int main(int argc, const char * argv[])
{
    Test2();
    
    //Test3();
    
    //    Mat imgROI = expect(Rect(1274,505,12,12));
    //    cout<<imgROI<<endl<<endl;
    //
    //    Mat imgROI2 = II(Rect(1274,505,12,12));
    //    cout<<imgROI2<<endl<<endl;
    //
    
    return 0;
}
